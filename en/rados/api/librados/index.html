
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Librados (C) &mdash; Ceph Documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     'dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="Ceph Documentation" href="../../../../" />
    <script type="text/javascript" src="http://ayni.ceph.com/public/js/ceph.js"></script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../">Ceph Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="librados-c">
<h1>Librados (C)<a class="headerlink" href="#librados-c" title="Permalink to this headline">¶</a></h1>
<p><cite>librados</cite> provides low-level access to the RADOS service. For an
overview of RADOS, see <a class="reference internal" href="../../../architecture/"><em>Architecture</em></a>.</p>
<div class="section" id="example-connecting-and-writing-an-object">
<h2>Example: connecting and writing an object<a class="headerlink" href="#example-connecting-and-writing-an-object" title="Permalink to this headline">¶</a></h2>
<p>To use <cite>Librados</cite>, you instantiate a <tt class="xref c c-type docutils literal"><span class="pre">rados_t</span></tt> variable (a cluster handle) and
call <tt class="xref c c-func docutils literal"><span class="pre">rados_create()</span></tt> with a pointer to it:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="kt">rados_t</span> <span class="n">cluster</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">rados_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: cannot create a cluster handle: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then you configure your <tt class="xref c c-type docutils literal"><span class="pre">rados_t</span></tt> to connect to your cluster,
either by setting individual values (<tt class="xref c c-func docutils literal"><span class="pre">rados_conf_set()</span></tt>),
using a configuration file (<tt class="xref c c-func docutils literal"><span class="pre">rados_conf_read_file()</span></tt>), using
command line options (<tt class="xref c c-func docutils literal"><span class="pre">rados_conf_parse_argv()</span></tt>), or an
environment variable (<tt class="xref c c-func docutils literal"><span class="pre">rados_conf_parse_env()</span></tt>):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">err</span> <span class="o">=</span> <span class="n">rados_conf_read_file</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="s">&quot;/path/to/myceph.conf&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: cannot read config file: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once the cluster handle is configured, you can connect to the cluster with <tt class="xref c c-func docutils literal"><span class="pre">rados_connect()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">err</span> <span class="o">=</span> <span class="n">rados_connect</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: cannot connect to cluster: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then you open an &#8220;IO context&#8221;, a <tt class="xref c c-type docutils literal"><span class="pre">rados_ioctx_t</span></tt>, with <tt class="xref c c-func docutils literal"><span class="pre">rados_ioctx_create()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">rados_ioctx_t</span> <span class="n">io</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">poolname</span> <span class="o">=</span> <span class="s">&quot;mypool&quot;</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">rados_ioctx_create</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">poolname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: cannot open rados pool %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poolname</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">rados_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the pool you try to access must exist.</p>
<p>Then you can use the RADOS data manipulation functions, for example
write into an object called <tt class="docutils literal"><span class="pre">greeting</span></tt> with
<tt class="xref c c-func docutils literal"><span class="pre">rados_write_full()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">err</span> <span class="o">=</span> <span class="n">rados_write_full</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;greeting&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: cannot write pool %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">poolname</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">rados_ioctx_destroy</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
        <span class="n">rados_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the end, you&#8217;ll want to close your IO context and connection to RADOS with <tt class="xref c c-func docutils literal"><span class="pre">rados_ioctx_destroy()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">rados_shutdown()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">rados_ioctx_destroy</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
<span class="n">rados_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="asychronous-io">
<h2>Asychronous IO<a class="headerlink" href="#asychronous-io" title="Permalink to this headline">¶</a></h2>
<p>When doing lots of IO, you often don&#8217;t need to wait for one operation
to complete before starting the next one. <cite>Librados</cite> provides
asynchronous versions of several operations:</p>
<ul class="simple">
<li><tt class="xref c c-func docutils literal"><span class="pre">rados_aio_write()</span></tt></li>
<li><tt class="xref c c-func docutils literal"><span class="pre">rados_aio_append()</span></tt></li>
<li><tt class="xref c c-func docutils literal"><span class="pre">rados_aio_write_full()</span></tt></li>
<li><tt class="xref c c-func docutils literal"><span class="pre">rados_aio_read()</span></tt></li>
</ul>
<p>For each operation, you must first create a
<tt class="xref c c-type docutils literal"><span class="pre">rados_completion_t</span></tt> that represents what to do when the
operation is safe or complete by calling
<tt class="xref c c-func docutils literal"><span class="pre">rados_aio_create_completion()</span></tt>. If you don&#8217;t need anything
special to happen, you can pass NULL:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">rados_completion_t</span> <span class="n">comp</span><span class="p">;</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">rados_aio_create_completion</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: could not create aio completion: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">rados_ioctx_destroy</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
        <span class="n">rados_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now you can call any of the aio operations, and wait for it to
be in memory or on disk on all replicas:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">err</span> <span class="o">=</span> <span class="n">rados_aio_write</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s: could not schedule aio write: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
        <span class="n">rados_aio_release</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
        <span class="n">rados_ioctx_destroy</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
        <span class="n">rados_shutdown</span><span class="p">(</span><span class="n">cluster</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">rados_wait_for_complete</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span> <span class="c1">// in memory</span>
<span class="n">rados_wait_for_safe</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span> <span class="c1">// on disk</span>
</pre></div>
</div>
<p>Finally, we need to free the memory used by the completion with <tt class="xref c c-func docutils literal"><span class="pre">rados_aio_release()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">rados_aio_release</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
</pre></div>
</div>
<p>You can use the callbacks to tell your application when writes are
durable, or when read buffers are full. For example, if you wanted to
measure the latency of each operation when appending to several
objects, you could schedule several writes and store the ack and
commit time in the corresponding callback, then wait for all of them
to complete using <tt class="xref c c-func docutils literal"><span class="pre">rados_aio_flush()</span></tt> before analyzing the
latencies:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">ack_end</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">commit_end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">req_duration</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">ack_callback</span><span class="p">(</span><span class="kt">rados_completion_t</span> <span class="n">comp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">req_duration</span> <span class="o">*</span><span class="n">dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">req_duration</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
        <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dur</span><span class="o">-&gt;</span><span class="n">ack_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">commit_callback</span><span class="p">(</span><span class="kt">rados_completion_t</span> <span class="n">comp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">req_duration</span> <span class="o">*</span><span class="n">dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">req_duration</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
        <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dur</span><span class="o">-&gt;</span><span class="n">commit_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">output_append_latency</span><span class="p">(</span><span class="kt">rados_ioctx_t</span> <span class="n">io</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_writes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">req_duration</span> <span class="n">times</span><span class="p">[</span><span class="n">num_writes</span><span class="p">];</span>
        <span class="kt">rados_completion_t</span> <span class="n">comps</span><span class="p">[</span><span class="n">num_writes</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_writes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">rados_aio_create_completion</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ack_callback</span><span class="p">,</span> <span class="n">commit_callback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error creating rados completion: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
                        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="kt">char</span> <span class="n">obj_name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
                <span class="n">snprintf</span><span class="p">(</span><span class="n">obj_name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">obj_name</span><span class="p">),</span> <span class="s">&quot;foo%ld&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">rados_aio_append</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">obj_name</span><span class="p">,</span> <span class="n">comps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error from rados_aio_append: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">));</span>
                        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// wait until all requests finish *and* the callbacks complete</span>
        <span class="n">rados_aio_flush</span><span class="p">(</span><span class="n">io</span><span class="p">);</span>
        <span class="c1">// the latencies can now be analyzed</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Request # | Ack latency (s) | Commit latency (s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_writes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// don&#39;t forget to free the completions</span>
                <span class="n">rados_aio_release</span><span class="p">(</span><span class="n">comps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="k">struct</span> <span class="n">timeval</span> <span class="n">ack_lat</span><span class="p">,</span> <span class="n">commit_lat</span><span class="p">;</span>
                <span class="n">timersub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ack_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ack_lat</span><span class="p">);</span>
                <span class="n">timersub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">commit_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commit_lat</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%9ld | %8ld.%06ld | %10ld.%06ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">i</span><span class="p">,</span> <span class="n">ack_lat</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ack_lat</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">,</span> <span class="n">commit_lat</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">commit_lat</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that all the <tt class="xref c c-type docutils literal"><span class="pre">rados_completion_t</span></tt> must be freed with <tt class="xref c c-func docutils literal"><span class="pre">rados_aio_release()</span></tt> to avoid leaking memory.</p>
</div>
<div class="section" id="api-calls">
<h2>API calls<a class="headerlink" href="#api-calls" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="LIBRADOS_ALL_NSPACES">
<span class="target" id="Cephrados__types_8h_1a856cbae08b44becba45c76f5da40ffa2"></span><tt class="descname">LIBRADOS_ALL_NSPACES</tt><a class="headerlink" href="#LIBRADOS_ALL_NSPACES" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass as nspace argument to rados_ioctx_set_namespace() before calling rados_nobjects_list_open() to return all objects in all namespaces. </p>
</dd></dl>

</div>
<dl class="class">
<dt id="obj_watch_t">
<span class="target" id="Cephstructobj__watch__t"></span><em class="property">struct </em><tt class="descname">obj_watch_t</tt><a class="headerlink" href="#obj_watch_t" title="Permalink to this definition">¶</a></dt>
<dd><em>#include &lt;rados_types.h&gt;</em><p>One item from list_watchers </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="obj_watch_t::addr__cA">
<span class="target" id="Cephstructobj__watch__t_1a5c521d5238d99ce7014905779cc3a2be"></span>char <tt class="descname">addr</tt>[256]<a class="headerlink" href="#obj_watch_t::addr__cA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="obj_watch_t::watcher_id__int64_t">
<span class="target" id="Cephstructobj__watch__t_1a9b773ca6095b61ee6154107d59939a50"></span>int64_t <tt class="descname">watcher_id</tt><a class="headerlink" href="#obj_watch_t::watcher_id__int64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="obj_watch_t::cookie__uint64_t">
<span class="target" id="Cephstructobj__watch__t_1a6c49bc31779a8d2511838a5e0cb5ff31"></span>uint64_t <tt class="descname">cookie</tt><a class="headerlink" href="#obj_watch_t::cookie__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="obj_watch_t::timeout_seconds__uint32_t">
<span class="target" id="Cephstructobj__watch__t_1a5e987bcbc17814f83d559920f5aab1dd"></span>uint32_t <tt class="descname">timeout_seconds</tt><a class="headerlink" href="#obj_watch_t::timeout_seconds__uint32_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</dd></dl>

<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">xattr comparison operations</p>
<p>Operators for comparing xattrs on objects, and aborting the rados_read_op or rados_write_op transaction if the comparison fails. </p>
<dl class="type">
<dt id="__anonymous1">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7"></span><em class="property">enum </em><tt class="descname"><strong>[anonymous]</strong></tt><a class="headerlink" href="#__anonymous1" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Values:</em></p>
<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_EQ">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7a5704c5de1214a67ec3e9583548ee6445"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_EQ</tt> = 1<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_EQ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_NE">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7ac83502a6846342c73e08b21ed3b14000"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_NE</tt> = 2<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_NE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_GT">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7a7dc00fff37f306f8607ba276efccee5c"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_GT</tt> = 3<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_GT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_GTE">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7a5a26abc77163a561d7bf619803c571c8"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_GTE</tt> = 4<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_GTE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_LT">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7abfdc72e29e7cbad7e278d5bbaf2a33bf"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_LT</tt> = 5<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_LT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_CMPXATTR_OP_LTE">
<span class="target" id="Cephlibrados_8h_1adf764cbdea00d65edcd07bb9953ad2b7ac5321f346c6a7022b0b3b42b83db72ee"></span><tt class="descname">LIBRADOS_CMPXATTR_OP_LTE</tt> = 6<a class="headerlink" href="#LIBRADOS_CMPXATTR_OP_LTE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Operation Flags</p>
<p>Flags for rados_read_op_opeprate(), rados_write_op_operate(), rados_aio_read_op_operate(), and rados_aio_write_op_operate(). See librados.hpp for details. </p>
<dl class="type">
<dt id="__anonymous2">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5"></span><em class="property">enum </em><tt class="descname"><strong>[anonymous]</strong></tt><a class="headerlink" href="#__anonymous2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Values:</em></p>
<dl class="member">
<dt id="LIBRADOS_OPERATION_NOFLAG">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5ad7f7f30ddb552d642d73a687a8bef0d8"></span><tt class="descname">LIBRADOS_OPERATION_NOFLAG</tt> = 0<a class="headerlink" href="#LIBRADOS_OPERATION_NOFLAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_BALANCE_READS">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5a497824d4474d47b623efbc0e196c453c"></span><tt class="descname">LIBRADOS_OPERATION_BALANCE_READS</tt> = 1<a class="headerlink" href="#LIBRADOS_OPERATION_BALANCE_READS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_LOCALIZE_READS">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5a542458b2695c3dd9a9e670dd85604ff9"></span><tt class="descname">LIBRADOS_OPERATION_LOCALIZE_READS</tt> = 2<a class="headerlink" href="#LIBRADOS_OPERATION_LOCALIZE_READS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_ORDER_READS_WRITES">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5ab107ef49cec1bcf177e55128308ade3e"></span><tt class="descname">LIBRADOS_OPERATION_ORDER_READS_WRITES</tt> = 4<a class="headerlink" href="#LIBRADOS_OPERATION_ORDER_READS_WRITES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_IGNORE_CACHE">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5afb3e7bac2e9fb9b9c54a7ed24750539d"></span><tt class="descname">LIBRADOS_OPERATION_IGNORE_CACHE</tt> = 8<a class="headerlink" href="#LIBRADOS_OPERATION_IGNORE_CACHE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_SKIPRWLOCKS">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5a7c30ed12a974a3082476aaac4528b7e5"></span><tt class="descname">LIBRADOS_OPERATION_SKIPRWLOCKS</tt> = 16<a class="headerlink" href="#LIBRADOS_OPERATION_SKIPRWLOCKS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OPERATION_IGNORE_OVERLAY">
<span class="target" id="Cephlibrados_8h_1a99fb83031ce9923c84392b4e92f956b5afab8b9d5a183456a775969623b452206"></span><tt class="descname">LIBRADOS_OPERATION_IGNORE_OVERLAY</tt> = 32<a class="headerlink" href="#LIBRADOS_OPERATION_IGNORE_OVERLAY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Asynchronous I/O</p>
<p>Read and write to objects without blocking. </p>
<dl class="type">
<dt id="rados_completion_t">
<span class="target" id="Cephlibrados_8h_1a103477d70e54fcefe12d6efeac226b95"></span><em class="property">typedef </em><tt class="descname">rados_completion_t</tt><a class="headerlink" href="#rados_completion_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the state of an asynchronous operation - it contains the return value once the operation completes, and can be used to block until the operation is complete or safe. </p>
</dd></dl>

<dl class="type">
<dt id="rados_callback_t">
<span class="target" id="Cephlibrados_8h_1a89fd019a165bb2872bbf9078d806a9e5"></span><em class="property">typedef </em><tt class="descname">rados_callback_t</tt><a class="headerlink" href="#rados_callback_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks for asynchrous operations take two parameters:<ul class="simple">
<li>cb the completion that has finished</li>
<li>arg application defined data made available to the callback function </li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a5955d25d7b509c9b271bd153a2208a10"></span><tt class="descname">CEPH_RADOS_API int rados_aio_create_completion(void * cb_arg, rados_callback_t cb_complete, rados_callback_t cb_safe, rados_completion_t * pc)</tt></dt>
<dd><p>Constructs a completion to use with asynchronous operations</p>
<p>The complete and safe callbacks correspond to operations being acked and committed, respectively. The callbacks are called in order of receipt, so the safe callback may be triggered before the complete callback, and vice versa. This is affected by journalling on the OSDs.</p>
<p>TODO: more complete documentation of this elsewhere (in the RADOS docs?)</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Read operations only get a complete callback. </dd>
<dt><strong>Note</strong></dt>
<dd>BUG: this should check for ENOMEM instead of throwing an exception</dd>
<dt><strong>Return</strong></dt>
<dd>0 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cb_arg</span></tt> - <p>application-defined data passed to the callback functions </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cb_complete</span></tt> - <p>the function to be called when the operation is in memory on all relpicas </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cb_safe</span></tt> - <p>the function to be called when the operation is on stable storage on all replicas </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pc</span></tt> - <p>where to store the completion </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a7718e4aaf9fe1f806bb981da8f4bd395"></span><tt class="descname">CEPH_RADOS_API int rados_aio_wait_for_complete(rados_completion_t c)</tt></dt>
<dd><p>Block until an operation completes</p>
<p>This means it is in memory on all replicas.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: this should be void</dd>
<dt><strong>Return</strong></dt>
<dd>0 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>operation to wait for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1acc3ccc5ff6beaa2cc04d5903a1662b58"></span><tt class="descname">CEPH_RADOS_API int rados_aio_wait_for_safe(rados_completion_t c)</tt></dt>
<dd><p>Block until an operation is safe</p>
<p>This means it is on stable storage on all replicas.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: this should be void</dd>
<dt><strong>Return</strong></dt>
<dd>0 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>operation to wait for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a32754a8fa76d9eb04af81c0c2670cb55"></span><tt class="descname">CEPH_RADOS_API int rados_aio_is_complete(rados_completion_t c)</tt></dt>
<dd><p>Has an asynchronous operation completed?</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This does not imply that the complete callback has finished</dd>
<dt><strong>Return</strong></dt>
<dd>whether c is complete </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>async operation to inspect </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a94bd058b887430fb0a48f137c024063e"></span><tt class="descname">CEPH_RADOS_API int rados_aio_is_safe(rados_completion_t c)</tt></dt>
<dd><p>Is an asynchronous operation safe?</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This does not imply that the safe callback has finished</dd>
<dt><strong>Return</strong></dt>
<dd>whether c is safe </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>async operation to inspect </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3532b567e6effae0af00d15dd9dd84f2"></span><tt class="descname">CEPH_RADOS_API int rados_aio_wait_for_complete_and_cb(rados_completion_t c)</tt></dt>
<dd><p>Block until an operation completes and callback completes</p>
<p>This means it is in memory on all replicas and can be read.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: this should be void</dd>
<dt><strong>Return</strong></dt>
<dd>0 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>operation to wait for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab7aede3e2a27cb520d1f6411bd5797a1"></span><tt class="descname">CEPH_RADOS_API int rados_aio_wait_for_safe_and_cb(rados_completion_t c)</tt></dt>
<dd><p>Block until an operation is safe and callback has completed</p>
<p>This means it is on stable storage on all replicas.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: this should be void</dd>
<dt><strong>Return</strong></dt>
<dd>0 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>operation to wait for </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a66135ad6d7f62d7dde361f4b0383ff33"></span><tt class="descname">CEPH_RADOS_API int rados_aio_is_complete_and_cb(rados_completion_t c)</tt></dt>
<dd><p>Has an asynchronous operation and callback completed</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>whether c is complete </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>async operation to inspect </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab1965ac4cda83410e829df7137e7dcdb"></span><tt class="descname">CEPH_RADOS_API int rados_aio_is_safe_and_cb(rados_completion_t c)</tt></dt>
<dd><p>Is an asynchronous operation safe and has the callback completed</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>whether c is safe </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>async operation to inspect </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad904db01b1c46e7373e5c7ba83dfc573"></span><tt class="descname">CEPH_RADOS_API int rados_aio_get_return_value(rados_completion_t c)</tt></dt>
<dd><p>Get the return value of an asychronous operation</p>
<p>The return value is set when the operation is complete or safe, whichever comes first.</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>The operation is safe or complete</dd>
<dt><strong>Note</strong></dt>
<dd>BUG: complete callback may never be called when the safe message is received before the complete message</dd>
<dt><strong>Return</strong></dt>
<dd>return value of the operation </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>async operation to inspect </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1adc6dfb15659856f9ca3dae564db4596d"></span><tt class="descname">CEPH_RADOS_API void rados_aio_release(rados_completion_t c)</tt></dt>
<dd><p>Release a completion</p>
<p>Call this when you no longer need the completion. It may not be freed immediately if the operation is not acked and committed.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">c</span></tt> - <p>completion to release </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a6f4f4c4bc2d9a37f462b57541cedc5c8"></span><tt class="descname">CEPH_RADOS_API int rados_aio_write(rados_ioctx_t io, const char * oid, rados_completion_t completion, const char * buf, size_t len, uint64_t off)</tt></dt>
<dd><p>Write data to an object asynchronously</p>
<p>Queues the write and returns. The return value of the completion will be 0 on success, negative error code on failure.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, -EROFS if the io context specifies a snap_seq other than LIBRADOS_SNAP_HEAD </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which the write will occur </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the write is safe and complete </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of the data, in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">off</span></tt> - <p>byte offset in the object to begin writing at </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a0a24821e17c314590c45f42f87b034d1"></span><tt class="descname">CEPH_RADOS_API int rados_aio_append(rados_ioctx_t io, const char * oid, rados_completion_t completion, const char * buf, size_t len)</tt></dt>
<dd><p>Asychronously append data to an object</p>
<p>Queues the append and returns.</p>
<p>The return value of the completion will be 0 on success, negative error code on failure.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, -EROFS if the io context specifies a snap_seq other than LIBRADOS_SNAP_HEAD </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the append is safe and complete </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>the data to append </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buf (in bytes) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1acf7daf8ecc0ba809b8bf6738b21af7ef"></span><tt class="descname">CEPH_RADOS_API int rados_aio_write_full(rados_ioctx_t io, const char * oid, rados_completion_t completion, const char * buf, size_t len)</tt></dt>
<dd><p>Asychronously write an entire object</p>
<p>The object is filled with the provided data. If the object exists, it is atomically truncated and then written. Queues the write_full and returns.</p>
<p>The return value of the completion will be 0 on success, negative error code on failure.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, -EROFS if the io context specifies a snap_seq other than LIBRADOS_SNAP_HEAD </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context in which the write will occur </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the write_full is safe and complete </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of the data, in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4b181e57f6ed40346af3b4445fcd0e58"></span><tt class="descname">CEPH_RADOS_API int rados_aio_remove(rados_ioctx_t io, const char * oid, rados_completion_t completion)</tt></dt>
<dd><p>Asychronously remove an object</p>
<p>Queues the remove and returns.</p>
<p>The return value of the completion will be 0 on success, negative error code on failure.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, -EROFS if the io context specifies a snap_seq other than LIBRADOS_SNAP_HEAD </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the remove is safe and complete </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1a8fd7f428bd26a8cc0a8c39dca950ad"></span><tt class="descname">CEPH_RADOS_API int rados_aio_read(rados_ioctx_t io, const char * oid, rados_completion_t completion, char * buf, size_t len, uint64_t off)</tt></dt>
<dd><p>Asychronously read data from an object</p>
<p>The io context determines the snapshot to read from, if any was set by rados_ioctx_snap_set_read().</p>
<p>The return value of the completion will be number of bytes read on success, negative error code on failure.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>only the &#8216;complete&#8217; callback of the completion will be called.</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to perform the read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the read is complete </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to store the results </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the number of bytes to read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">off</span></tt> - <p>the offset to start reading from in the object </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a644b4e62503d9eb0f3b2b618860c6eba"></span><tt class="descname">CEPH_RADOS_API int rados_aio_flush(rados_ioctx_t io)</tt></dt>
<dd><p>Block until all pending writes in an io context are safe</p>
<p>This is not equivalent to calling rados_aio_wait_for_safe() on all write completions, since this waits for the associated callbacks to complete as well.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: always returns 0, should be void or accept a timeout</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to flush </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1acb4e47ec4b917eaf11027389b2064b13"></span><tt class="descname">CEPH_RADOS_API int rados_aio_flush_async(rados_ioctx_t io, rados_completion_t completion)</tt></dt>
<dd><p>Schedule a callback for when all currently pending aio writes are safe. This is a non-blocking version of rados_aio_flush().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to flush </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when the writes are safe </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a99280f0e640f0849a6fb91ec742f0e80"></span><tt class="descname">CEPH_RADOS_API int rados_aio_stat(rados_ioctx_t io, const char * o, rados_completion_t completion, uint64_t * psize, time_t * pmtime)</tt></dt>
<dd><p>Asynchronously get object stats (size/mtime)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>object name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">psize</span></tt> - <p>where to store object size </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pmtime</span></tt> - <p>where to store modification time </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a59638b9177c9ccf52d19f1d992277503"></span><tt class="descname">CEPH_RADOS_API int rados_aio_cancel(rados_ioctx_t io, rados_completion_t completion)</tt></dt>
<dd><p>Cancel async operation</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>completion handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Watch/Notify</p>
<p>Watch/notify is a protocol to help communicate among clients. It can be used to sychronize client state. All that&#8217;s needed is a well-known object name (for example, rbd uses the header object of an image).</p>
<p>Watchers register an interest in an object, and receive all notifies on that object. A notify attempts to communicate with all clients watching an object, and blocks on the notifier until each client responds or a timeout is reached.</p>
<p>See rados_watch() and rados_notify() for more details. </p>
<dl class="type">
<dt id="rados_watchcb_t">
<span class="target" id="Cephlibrados_8h_1a3ed009a14f2fd15dc7a4fe337f3649d5"></span><em class="property">typedef </em><tt class="descname">rados_watchcb_t</tt><a class="headerlink" href="#rados_watchcb_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback activated when a notify is received on a watched object.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: opcode is an internal detail that shouldn&#8217;t be exposed </dd>
<dt><strong>Note</strong></dt>
<dd>BUG: ver is unused </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">opcode</span></tt> - <p>undefined </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ver</span></tt> - <p>version of the watched object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">arg</span></tt> - <p>application-specific data</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="rados_watchcb2_t">
<span class="target" id="Cephlibrados_8h_1ae4042feb1602b9df19dac7ff496920d3"></span><em class="property">typedef </em><tt class="descname">rados_watchcb2_t</tt><a class="headerlink" href="#rados_watchcb2_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback activated when a notify is received on a watched object.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">arg</span></tt> - <p>opaque user-defined value provided to rados_watch2() </p>
</li>
<li><tt class="first docutils literal"><span class="pre">notify_id</span></tt> - <p>an id for this notify event </p>
</li>
<li><tt class="first docutils literal"><span class="pre">handle</span></tt> - <p>the watcher handle we are notifying </p>
</li>
<li><tt class="first docutils literal"><span class="pre">notifier_id</span></tt> - <p>the unique client id for the notifier </p>
</li>
<li><tt class="first docutils literal"><span class="pre">data</span></tt> - <p>payload from the notifier </p>
</li>
<li><tt class="first docutils literal"><span class="pre">datalen</span></tt> - <p>length of payload buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="rados_watcherrcb_t">
<span class="target" id="Cephlibrados_8h_1a03fa31d268200b63ae696a9b7d7806f4"></span><em class="property">typedef </em><tt class="descname">rados_watcherrcb_t</tt><a class="headerlink" href="#rados_watcherrcb_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback activated when we encounter an error with the watch session. This can happen when the location of the objects moves within the cluster and we fail to register our watch with the new object location, or when our connection with the object OSD is otherwise interrupted and we may have missed notify events.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">pre</span></tt> - <p>opaque user-defined value provided to rados_watch2() </p>
</li>
<li><tt class="first docutils literal"><span class="pre">err</span></tt> - <p>error code </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a6f26b36eb0042935caf4338a447e473b"></span><tt class="descname">CEPH_RADOS_API int rados_watch(rados_ioctx_t io, const char * o, uint64_t ver, uint64_t * cookie, rados_watchcb_t watchcb, void * arg)</tt></dt>
<dd><p>Register an interest in an object</p>
<p>A watch operation registers the client as being interested in notifications on an object. OSDs keep track of watches on persistent storage, so they are preserved across cluster changes by the normal recovery process. If the client loses its connection to the primary OSD for a watched object, the watch will be removed after 30 seconds. Watches are automatically reestablished when a new connection is made, or a placement group switches OSDs.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: watch timeout should be configurable </dd>
<dt><strong>Note</strong></dt>
<dd>BUG: librados should provide a way for watchers to notice connection resets </dd>
<dt><strong>Note</strong></dt>
<dd>BUG: the ver parameter does not work, and -ERANGE will never be returned (See URL tracker.ceph.com/issues/2592)</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE if the version of the object is greater than ver </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the object to watch </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ver</span></tt> - <p>expected version of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>where to store the internal id assigned to this watch </p>
</li>
<li><tt class="first docutils literal"><span class="pre">watchcb</span></tt> - <p>what to do when a notify is received on this object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">arg</span></tt> - <p>application defined data to pass when watchcb is called </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1e9999a4cab56748425c53b436c9f3ff"></span><tt class="descname">CEPH_RADOS_API int rados_watch2(rados_ioctx_t io, const char * o, uint64_t * cookie, rados_watchcb2_t watchcb, rados_watcherrcb_t watcherrcb, void * arg)</tt></dt>
<dd><p>Register an interest in an object</p>
<p>A watch operation registers the client as being interested in notifications on an object. OSDs keep track of watches on persistent storage, so they are preserved across cluster changes by the normal recovery process. If the client loses its connection to the primary OSD for a watched object, the watch will be removed after 30 seconds. Watches are automatically reestablished when a new connection is made, or a placement group switches OSDs.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: watch timeout should be configurable</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the object to watch </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>where to store the internal id assigned to this watch </p>
</li>
<li><tt class="first docutils literal"><span class="pre">watchcb</span></tt> - <p>what to do when a notify is received on this object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">watcherrcb</span></tt> - <p>what to do when the watch session encounters an error </p>
</li>
<li><tt class="first docutils literal"><span class="pre">arg</span></tt> - <p>opaque value to pass to the callback </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a41031bd4a4fe0515507bc62b12c7c34f"></span><tt class="descname">CEPH_RADOS_API int rados_watch_check(rados_ioctx_t io, uint64_t cookie)</tt></dt>
<dd><p>Check on the status of a watch</p>
<p>Return the number of milliseconds since the watch was last confirmed. Or, if there has been an error, return that.</p>
<p>If there is an error, the watch is no longer valid, and should be destroyed with rados_unwatch2(). The the user is still interested in the object, a new watch should be created with rados_watch2().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ms since last confirmed on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>the watch handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad83de38adfb370d9e0aa11476a1d0fb2"></span><tt class="descname">CEPH_RADOS_API int rados_unwatch(rados_ioctx_t io, const char * o, uint64_t cookie)</tt></dt>
<dd><p>Unregister an interest in an object</p>
<p>Once this completes, no more notifies will be sent to us for this watch. This should be called to clean up unneeded watchers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the watched object (ignored) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>which watch to unregister </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af7468fc1e70070f2e306a6729e10a3ce"></span><tt class="descname">CEPH_RADOS_API int rados_unwatch2(rados_ioctx_t io, uint64_t cookie)</tt></dt>
<dd><p>Unregister an interest in an object</p>
<p>Once this completes, no more notifies will be sent to us for this watch. This should be called to clean up unneeded watchers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>which watch to unregister </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ae3370754262b3593eb320c021782fb6c"></span><tt class="descname">CEPH_RADOS_API int rados_notify(rados_ioctx_t io, const char * o, uint64_t ver, const char * buf, int buf_len)</tt></dt>
<dd><p>Sychronously notify watchers of an object</p>
<p>This blocks until all watchers of the object have received and reacted to the notify, or a timeout is reached.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: the timeout is not changeable via the C API </dd>
<dt><strong>Note</strong></dt>
<dd>BUG: the bufferlist is inaccessible in a rados_watchcb_t</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ver</span></tt> - <p>obsolete - just pass zero </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to send to watchers </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf_len</span></tt> - <p>length of buf in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac14c542aeec3a5e5a2438f0e0fc511bd"></span><tt class="descname">CEPH_RADOS_API int rados_notify2(rados_ioctx_t io, const char * o, const char * buf, int buf_len, uint64_t timeout_ms, char ** reply_buffer, size_t * reply_buffer_len)</tt></dt>
<dd><p>Sychronously notify watchers of an object</p>
<p>This blocks until all watchers of the object have received and reacted to the notify, or a timeout is reached.</p>
<p>The reply buffer is optional. If specified, the client will get back an encoded buffer that includes the ids of the clients that acknowledged the notify as well as their notify ack payloads (if any). Clients that timed out are not included. Even clients that do not include a notify ack payload are included in the list but have a 0-length payload associated with them. The format:</p>
<p>le32 num_acks { le64 gid global id for the client (for client.1234 that&#8217;s 1234) le64 cookie cookie for the client le32 buflen length of reply message buffer u8 * buflen payload } * num_acks le32 num_timeouts { le64 gid global id for the client le64 cookie cookie for the client } * num_timeouts</p>
<p>Note: There may be multiple instances of the same gid if there are multiple watchers registered via the same client.</p>
<p>Note: The buffer must be released with rados_buffer_free() when the user is done with it.</p>
<p>Note: Since the result buffer includes clients that time out, it will be set even when rados_notify() returns an error code (like -ETIMEDOUT).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to send to watchers </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf_len</span></tt> - <p>length of buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">timeout_ms</span></tt> - <p>notify timeout (in ms) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">reply_buffer</span></tt> - <p>pointer to reply buffer pointer (free with rados_buffer_free) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">reply_buffer_len</span></tt> - <p>pointer to size of reply buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aa9190c17b299ea172324ecd2f82559f1"></span><tt class="descname">CEPH_RADOS_API int rados_notify_ack(rados_ioctx_t io, const char * o, uint64_t notify_id, uint64_t cookie, const char * buf, int buf_len)</tt></dt>
<dd><p>Acknolwedge receipt of a notify</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">notify_id</span></tt> - <p>the notify_id we got on the watchcb2_t callback </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>the watcher handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>payload to return to notifier (optional) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf_len</span></tt> - <p>payload length </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a318a5626111fcebbc9133720a253003c"></span><tt class="descname">CEPH_RADOS_API int rados_watch_flush(rados_t cluster)</tt></dt>
<dd><p>Flush watch/notify callbacks</p>
<p>This call will block until all pending watch/notify callbacks have been executed and the queue is empty. It should usually be called after shutting down any watches before shutting down the ioctx or librados to ensure that any callbacks do not misuse the ioctx (for example by calling rados_notify_ack after the ioctx has been destroyed).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Mon/OSD/PG Commands</p>
<p>These interfaces send commands relating to the monitor, OSD, or PGs. </p>
<dl class="type">
<dt>
<span class="target" id="Cephlibrados_8h_1ab4022414e832a8474f354826b71b9e59"></span><em class="property">typedef </em><tt class="descname">void(* rados_log_callback_t) (void *arg, const char *line, const char *who, uint64_t sec, uint64_t nsec, uint64_t seq, const char *level, const char *msg)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aa99ad43fce68696b2ef3710436807c70"></span><tt class="descname">CEPH_RADOS_API int rados_mon_command(rados_t cluster, const char ** cmd, size_t cmdlen, const char * inbuf, size_t inbuflen, char ** outbuf, size_t * outbuflen, char ** outs, size_t * outslen)</tt></dt>
<dd><p>Send monitor command.</p>
<p>
The result buffers are allocated on the heap; the caller is expected to release that memory with rados_buffer_free(). The buffer and length pointers can all be NULL, in which case they are not filled in.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Takes command string in carefully-formatted JSON; must match defined commands, types, etc.</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmd</span></tt> - <p>an array of char *&#8217;s representing the command </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmdlen</span></tt> - <p>count of valid entries in cmd </p>
</li>
<li><tt class="first docutils literal"><span class="pre">inbuf</span></tt> - <p>any bulk input data (crush map, etc.) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outbuf</span></tt> - <p>double pointer to output buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outbuflen</span></tt> - <p>pointer to output buffer length </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outs</span></tt> - <p>double pointer to status string </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outslen</span></tt> - <p>pointer to status string length </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a6e3012a57bd3f377b2cc85be6aacb940"></span><tt class="descname">CEPH_RADOS_API int rados_mon_command_target(rados_t cluster, const char * name, const char ** cmd, size_t cmdlen, const char * inbuf, size_t inbuflen, char ** outbuf, size_t * outbuflen, char ** outs, size_t * outslen)</tt></dt>
<dd><p>Send monitor command to a specific monitor.</p>
<p>
The result buffers are allocated on the heap; the caller is expected to release that memory with rados_buffer_free(). The buffer and length pointers can all be NULL, in which case they are not filled in.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Takes command string in carefully-formatted JSON; must match defined commands, types, etc.</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>target monitor&#8217;s name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmd</span></tt> - <p>an array of char *&#8217;s representing the command </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmdlen</span></tt> - <p>count of valid entries in cmd </p>
</li>
<li><tt class="first docutils literal"><span class="pre">inbuf</span></tt> - <p>any bulk input data (crush map, etc.) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outbuf</span></tt> - <p>double pointer to output buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outbuflen</span></tt> - <p>pointer to output buffer length </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outs</span></tt> - <p>double pointer to status string </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outslen</span></tt> - <p>pointer to status string length </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ae9e2a3c60e90c9a6ffee2b375323277e"></span><tt class="descname">CEPH_RADOS_API void rados_buffer_free(char * buf)</tt></dt>
<dd><p>free a rados-allocated buffer</p>
<p>Release memory allocated by librados calls like rados_mon_command().</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>buffer pointer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac4f964d0905d7fa0e4706472b1b32ece"></span><tt class="descname">CEPH_RADOS_API int rados_osd_command(rados_t cluster, int osdid, const char ** cmd, size_t cmdlen, const char * inbuf, size_t inbuflen, char ** outbuf, size_t * outbuflen, char ** outs, size_t * outslen)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ae5f01307bed3525328794aefaa1ed0bf"></span><tt class="descname">CEPH_RADOS_API int rados_pg_command(rados_t cluster, const char * pgstr, const char ** cmd, size_t cmdlen, const char * inbuf, size_t inbuflen, char ** outbuf, size_t * outbuflen, char ** outs, size_t * outslen)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1347de47c1844df177a3e96388e57843"></span><tt class="descname">CEPH_RADOS_API int rados_monitor_log(rados_t cluster, const char * level, rados_log_callback_t cb, void * arg)</tt></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Setup and Teardown</p>
<p>These are the first and last functions to that should be called when using librados. </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aa9742cf78cb317220fd7d88bfa4c4fe1"></span><tt class="descname">CEPH_RADOS_API int rados_create(rados_t * cluster, const char *const id)</tt></dt>
<dd><p>Create a handle for communicating with a RADOS cluster.</p>
<p>Ceph environment variables are read when this is called, so if $CEPH_ARGS specifies everything you need to connect, no further configuration is necessary.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>where to store the handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">id</span></tt> - <p>the user to connect as (i.e. admin, not client.admin) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1bca04c057fb4c8c1dea33d78aa1f4c8"></span><tt class="descname">CEPH_RADOS_API int rados_create2(rados_t * pcluster, const char *const clustername, const char *const name, uint64_t flags)</tt></dt>
<dd><p>Extended version of rados_create.</p>
<p>Like rados_create, but 1) don&#8217;t assume &#8216;client.&#8217;+id; allow full specification of name 2) allow specification of cluster name 3) flags for future expansion </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af60d8e0acb6e3220642dc1a9c0254fd6"></span><tt class="descname">CEPH_RADOS_API int rados_create_with_context(rados_t * cluster, rados_config_t cct)</tt></dt>
<dd><p>Initialize a cluster handle from an existing configuration.</p>
<p>Share configuration state with another rados_t instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>where to store the handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cct</span></tt> - <p>the existing configuration to use </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a61b0803b9e25117e18da841af05bedd2"></span><tt class="descname">CEPH_RADOS_API int rados_ping_monitor(rados_t cluster, const char * mon_id, char ** outstr, size_t * outstrlen)</tt></dt>
<dd><p>Ping the monitor with ID mon_id, storing the resulting reply in buf (if specified) with a maximum size of len.</p>
<p>The result buffer is allocated on the heap; the caller is expected to release that memory with rados_buffer_free(). The buffer and length pointers can be NULL, in which case they are not filled in.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">mon_id</span></tt> - <p>ID of the monitor to ping </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outstr</span></tt> - <p>double pointer with the resulting reply </p>
</li>
<li><tt class="first docutils literal"><span class="pre">outstrlen</span></tt> - <p>pointer with the size of the reply in outstr </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4176493c4660ee4e575351b27f1e5716"></span><tt class="descname">CEPH_RADOS_API int rados_connect(rados_t cluster)</tt></dt>
<dd><p>Connect to the cluster.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>BUG: Before calling this, calling a function that communicates with the cluster will crash.</dd>
<dt><strong>Pre</strong></dt>
<dd>The cluster handle is configured with at least a monitor address. If cephx is enabled, a client name and secret must also be set.</dd>
<dt><strong>Post</strong></dt>
<dd>If this succeeds, any function in librados may be used</dd>
<dt><strong>Return</strong></dt>
<dd>0 on sucess, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>The cluster to connect to. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4c22ecfd1a92786498dc8813e6b87d4b"></span><tt class="descname">CEPH_RADOS_API void rados_shutdown(rados_t cluster)</tt></dt>
<dd><p>Disconnects from the cluster.</p>
<p>For clean up, this is only necessary after rados_connect() has succeeded.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This does not guarantee any asynchronous writes have completed. To do that, you must call rados_aio_flush() on all open io contexts.</dd>
<dt><strong>Warning</strong></dt>
<dd>We implicitly call rados_watch_flush() on shutdown. If there are watches being used, this should be done explicitly before destroying the relevant IoCtx. We do it here as a safety measure.</dd>
<dt><strong>Post</strong></dt>
<dd>the cluster handle cannot be used again</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster to shutdown </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Configuration</p>
<p>These functions read and update Ceph configuration for a cluster handle. Any configuration changes must be done before connecting to the cluster.</p>
<p>Options that librados users might want to set include:<ul class="simple">
<li>mon_host</li>
<li>auth_supported</li>
<li>key, keyfile, or keyring when using cephx</li>
<li>log_file, log_to_stderr, err_to_stderr, and log_to_syslog</li>
<li>debug_rados, debug_objecter, debug_monc, debug_auth, or debug_ms</li>
</ul>
</p>
<p>All possible options can be found in src/common/config_opts.h in ceph.git </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a5170b2ff56c95ee659d296ffcaa93850"></span><tt class="descname">CEPH_RADOS_API int rados_conf_read_file(rados_t cluster, const char * path)</tt></dt>
<dd><p>Configure the cluster handle using a Ceph config file</p>
<p>If path is NULL, the default locations are searched, and the first found is used. The locations are:<ul class="simple">
<li>$CEPH_CONF (environment variable)</li>
<li>/etc/ceph/ceph.conf</li>
<li>~/.ceph/config</li>
<li>ceph.conf (in the current working directory)</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>rados_connect() has not been called on the cluster handle</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle to configure </p>
</li>
<li><tt class="first docutils literal"><span class="pre">path</span></tt> - <p>path to a Ceph configuration file </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2db871e5def16fffe89cfa6a15d15c7d"></span><tt class="descname">CEPH_RADOS_API int rados_conf_parse_argv(rados_t cluster, int argc, const char ** argv)</tt></dt>
<dd><p>Configure the cluster handle with command line arguments</p>
<p>argv can contain any common Ceph command line option, including any configuration parameter prefixed by &#8216;&#8216; and replacing spaces with dashes or underscores. For example, the following options are equivalent:<ul class="simple">
<li>mon-host 10.0.0.1:6789</li>
<li>mon_host 10.0.0.1:6789</li>
<li>-m 10.0.0.1:6789</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>rados_connect() has not been called on the cluster handle</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle to configure </p>
</li>
<li><tt class="first docutils literal"><span class="pre">argc</span></tt> - <p>number of arguments in argv </p>
</li>
<li><tt class="first docutils literal"><span class="pre">argv</span></tt> - <p>arguments to parse </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4b940f3adbd61b9bfc61c70180f99a2a"></span><tt class="descname">CEPH_RADOS_API int rados_conf_parse_argv_remainder(rados_t cluster, int argc, const char ** argv, const char ** remargv)</tt></dt>
<dd><p>Configure the cluster handle with command line arguments, returning any remainders. Same rados_conf_parse_argv, except for extra remargv argument to hold returns unrecognized arguments.</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>rados_connect() has not been called on the cluster handle</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle to configure </p>
</li>
<li><tt class="first docutils literal"><span class="pre">argc</span></tt> - <p>number of arguments in argv </p>
</li>
<li><tt class="first docutils literal"><span class="pre">argv</span></tt> - <p>arguments to parse </p>
</li>
<li><tt class="first docutils literal"><span class="pre">remargv</span></tt> - <p>char* array for returned unrecognized arguments </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a8d01404bf97ef89f6e8b71253cf387fa"></span><tt class="descname">CEPH_RADOS_API int rados_conf_parse_env(rados_t cluster, const char * var)</tt></dt>
<dd><p>Configure the cluster handle based on an environment variable</p>
<p>The contents of the environment variable are parsed as if they were Ceph command line options. If var is NULL, the CEPH_ARGS environment variable is used.</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>rados_connect() has not been called on the cluster handle</dd>
<dt><strong>Note</strong></dt>
<dd>BUG: this is not threadsafe - it uses a static buffer</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle to configure </p>
</li>
<li><tt class="first docutils literal"><span class="pre">var</span></tt> - <p>name of the environment variable to read </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a668b1ea063260d532866f840d3acac9a"></span><tt class="descname">CEPH_RADOS_API int rados_conf_set(rados_t cluster, const char * option, const char * value)</tt></dt>
<dd><p>Set a configuration option</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>rados_connect() has not been called on the cluster handle</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ENOENT when the option is not a Ceph configuration option </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle to configure </p>
</li>
<li><tt class="first docutils literal"><span class="pre">option</span></tt> - <p>option to set </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value</span></tt> - <p>value of the option </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1abfc74223915b1454cae8052255502d52"></span><tt class="descname">CEPH_RADOS_API int rados_conf_get(rados_t cluster, const char * option, char * buf, size_t len)</tt></dt>
<dd><p>Get the value of a configuration option</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ENAMETOOLONG if the buffer is too short to contain the requested value </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>configuration to read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">option</span></tt> - <p>which option to read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to write the configuration value </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the size of buf in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Pools</p>
<p>RADOS pools are separate namespaces for objects. Pools may have different crush rules associated with them, so they could have differing replication levels or placement strategies. RADOS permissions are also tied to pools - users can have different read, write, and execute permissions on a per-pool basis. </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a7c704b5329e2fbbbcb4707f3b9eb645e"></span><tt class="descname">CEPH_RADOS_API int rados_pool_list(rados_t cluster, char * buf, size_t len)</tt></dt>
<dd><p>List pools</p>
<p>Gets a list of pool names as NULL-terminated strings. The pool names will be placed in the supplied buffer one after another. After the last pool name, there will be two 0 bytes in a row.</p>
<p>If len is too short to fit all the pool name entries we need, we will fill as much as we can.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>length of the buffer we would need to list all pools </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>output buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>output buffer length </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad187e4b926e52afb36ae11d0e13c4ead"></span><tt class="descname">CEPH_RADOS_API rados_config_t rados_cct(rados_t cluster)</tt></dt>
<dd><p>Get a configuration handle for a rados cluster handle</p>
<p>This handle is valid only as long as the cluster handle is valid.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>config handle for this cluster </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3822759cc115c7c765e079a9d641a799"></span><tt class="descname">CEPH_RADOS_API uint64_t rados_get_instance_id(rados_t cluster)</tt></dt>
<dd><p>Get a global id for current instance</p>
<p>This id is a unique representation of current connection to the cluster</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>instance global id </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac24160ffe35b9ace2e2e331ae4090681"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_create(rados_t cluster, const char * pool_name, rados_ioctx_t * ioctx)</tt></dt>
<dd><p>Create an io context</p>
<p>The io context allows you to perform operations within a particular pool. For more details see rados_ioctx_t.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>which cluster the pool is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>name of the pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ioctx</span></tt> - <p>where to store the io context </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af2a155a7adb7612397b702497bbdc3a5"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_create2(rados_t cluster, int64_t pool_id, rados_ioctx_t * ioctx)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3f705343b9053c2524465a72c4bdc861"></span><tt class="descname">CEPH_RADOS_API void rados_ioctx_destroy(rados_ioctx_t io)</tt></dt>
<dd><p>The opposite of rados_ioctx_create</p>
<p>This just tells librados that you no longer need to use the io context. It may not be freed immediately if there are pending asynchronous requests on it, but you should not use an io context again after calling this function on it.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This does not guarantee any asynchronous writes have completed. You must call rados_aio_flush() on the io context before destroying it to do that.</dd>
<dt><strong>Warning</strong></dt>
<dd>If this ioctx is used by rados_watch, the caller needs to be sure that all registered watches are disconnected via rados_unwatch() and that rados_watch_flush() is called. This ensures that a racing watch callback does not make use of a destroyed ioctx.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to dispose of </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a03cd4b9a87140e7835b6ffb72c8187d2"></span><tt class="descname">CEPH_RADOS_API rados_config_t rados_ioctx_cct(rados_ioctx_t io)</tt></dt>
<dd><p>Get configuration hadnle for a pool handle</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>rados_config_t for this cluster </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>pool handle </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab251a7fc84fb169edd138d7ec15d8c5e"></span><tt class="descname">CEPH_RADOS_API rados_t rados_ioctx_get_cluster(rados_ioctx_t io)</tt></dt>
<dd><p>Get the cluster handle used by this rados_ioctx_t Note that this is a weak reference, and should not be destroyed via rados_shutdown().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the cluster handle for this io context </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac3b3523507dc0ac32a83e22a2eee0656"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_pool_stat(rados_ioctx_t io, struct  rados_pool_stat_t  * stats)</tt></dt>
<dd><p>Get pool usage statistics</p>
<p>Fills in a <a class="reference internal" href="../../../../rados/api/librados/#Cephstructrados__pool__stat__t"><em>rados_pool_stat_t</em></a> after querying the cluster.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>determines which pool to query </p>
</li>
<li><tt class="first docutils literal"><span class="pre">stats</span></tt> - <p>where to store the results </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab094a6ef983aa2d1bb54566642b918e5"></span><tt class="descname">CEPH_RADOS_API int64_t rados_pool_lookup(rados_t cluster, const char * pool_name)</tt></dt>
<dd><p>Get the id of a pool</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>id of the pool </dd>
<dt><strong>Return</strong></dt>
<dd>-ENOENT if the pool is not found </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>which cluster the pool is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>which pool to look up </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2e9949fa2709a5c121aef94fbaa9ad46"></span><tt class="descname">CEPH_RADOS_API int rados_pool_reverse_lookup(rados_t cluster, int64_t id, char * buf, size_t maxlen)</tt></dt>
<dd><p>Get the name of a pool</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>length of string stored, or -ERANGE if buffer too small </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>which cluster the pool is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">id</span></tt> - <p>the id of the pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to store the pool name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">maxlen</span></tt> - <p>size of buffer where name will be stored </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a0007dc3d96a17f5df1effcd3d079f0ec"></span><tt class="descname">CEPH_RADOS_API int rados_pool_create(rados_t cluster, const char * pool_name)</tt></dt>
<dd><p>Create a pool with default settings</p>
<p>The default owner is the admin user (auid 0). The default crush rule is rule 0.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster in which the pool will be created </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>the name of the new pool </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a0ddaa1aa21e3ec37b16d2664fa040fab"></span><tt class="descname">CEPH_RADOS_API int rados_pool_create_with_auid(rados_t cluster, const char * pool_name, uint64_t auid)</tt></dt>
<dd><p>Create a pool owned by a specific auid</p>
<p>The auid is the authenticated user id to give ownership of the pool. TODO: document auid and the rest of the auth system</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster in which the pool will be created </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>the name of the new pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">auid</span></tt> - <p>the id of the owner of the new pool </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4de57d42b5856c289fde94611b92ef00"></span><tt class="descname">CEPH_RADOS_API int rados_pool_create_with_crush_rule(rados_t cluster, const char * pool_name, uint8_t crush_rule_num)</tt></dt>
<dd><p>Create a pool with a specific CRUSH rule</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster in which the pool will be created </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>the name of the new pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">crush_rule_num</span></tt> - <p>which rule to use for placement in the new pool1 </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a9f06b11e9f39cc2058759ffc924c376f"></span><tt class="descname">CEPH_RADOS_API int rados_pool_create_with_all(rados_t cluster, const char * pool_name, uint64_t auid, uint8_t crush_rule_num)</tt></dt>
<dd><p>Create a pool with a specific CRUSH rule and auid</p>
<p>This is a combination of rados_pool_create_with_crush_rule() and rados_pool_create_with_auid().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster in which the pool will be created </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>the name of the new pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">crush_rule_num</span></tt> - <p>which rule to use for placement in the new pool2 </p>
</li>
<li><tt class="first docutils literal"><span class="pre">auid</span></tt> - <p>the id of the owner of the new pool </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a39453238a28559db6285d37e4f146fda"></span><tt class="descname">CEPH_RADOS_API int rados_pool_get_base_tier(rados_t cluster, int64_t pool, int64_t * base_tier)</tt></dt>
<dd><p>Returns the pool that is the base tier for this pool.</p>
<p>The return value is the ID of the pool that should be used to read from/write to. If tiering is not set up for the pool, returns <tt class="docutils literal"><span class="pre">pool</span></tt>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster the pool is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool</span></tt> - <p>ID of the pool to query </p>
</li>
<li><tt class="first docutils literal"><span class="pre">base_tier</span></tt> - <p>base tier, or <tt class="docutils literal"><span class="pre">pool</span></tt> if tiering is not configured </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a01ebc54925104a5448e683ce84691db6"></span><tt class="descname">CEPH_RADOS_API int rados_pool_delete(rados_t cluster, const char * pool_name)</tt></dt>
<dd><p>Delete a pool and all data inside it</p>
<p>The pool is removed from the cluster immediately, but the actual data is deleted in the background.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster the pool is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pool_name</span></tt> - <p>which pool to delete </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a41fa47100a5008e566b37fc8fa3a5188"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_pool_set_auid(rados_ioctx_t io, uint64_t auid)</tt></dt>
<dd><p>Attempt to change an io context&#8217;s associated auid &#8220;owner.&#8221;</p>
<p>Requires that you have write permission on both the current and new auid.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>reference to the pool to change. </p>
</li>
<li><tt class="first docutils literal"><span class="pre">auid</span></tt> - <p>the auid you wish the io to have. </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a37ec07eec1dfe00e0629c2d48bf273a9"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_pool_get_auid(rados_ioctx_t io, uint64_t * auid)</tt></dt>
<dd><p>Get the auid of a pool</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>pool to query </p>
</li>
<li><tt class="first docutils literal"><span class="pre">auid</span></tt> - <p>where to store the auid </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af929c189373f83bc50e58c332ade0f46"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_pool_requires_alignment(rados_ioctx_t io)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a45d4c483428e168a1986f45ba0dfd2e7"></span><tt class="descname">CEPH_RADOS_API uint64_t rados_ioctx_pool_required_alignment(rados_ioctx_t io)</tt></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4c3d4ac83a5232c2a4ccec46ddb025bb"></span><tt class="descname">CEPH_RADOS_API int64_t rados_ioctx_get_id(rados_ioctx_t io)</tt></dt>
<dd><p>Get the pool id of the io context</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the id of the pool the io context uses </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to query </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad607af55d4850b4a079bd53949ab993b"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_get_pool_name(rados_ioctx_t io, char * buf, unsigned maxlen)</tt></dt>
<dd><p>Get the pool name of the io context</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>length of string stored, or -ERANGE if buffer too small </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to query </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>pointer to buffer where name will be stored </p>
</li>
<li><tt class="first docutils literal"><span class="pre">maxlen</span></tt> - <p>size of buffer where name will be stored </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Object Locators</p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2e89c516a1d2d462b3e37f4b71ff8313"></span><tt class="descname">CEPH_RADOS_API void rados_ioctx_locator_set_key(rados_ioctx_t io, const char * key)</tt></dt>
<dd><p>Set the key for mapping objects to pgs within an io context.</p>
<p>The key is used instead of the object name to determine which placement groups an object is put in. This affects all subsequent operations of the io context - until a different locator key is set, all objects in this io context will be placed in the same pg.</p>
<p>This is useful if you need to do clone_range operations, which must be done with the source and destination objects in the same pg.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to change </p>
</li>
<li><tt class="first docutils literal"><span class="pre">key</span></tt> - <p>the key to use as the object locator, or NULL to discard any previously set key </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab8ee4979c52cf36a32db54a9529b327b"></span><tt class="descname">CEPH_RADOS_API void rados_ioctx_set_namespace(rados_ioctx_t io, const char * nspace)</tt></dt>
<dd><p>Set the namespace for objects within an io context</p>
<p>The namespace specification further refines a pool into different domains. The mapping of objects to pgs is also based on this value.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to change </p>
</li>
<li><tt class="first docutils literal"><span class="pre">nspace</span></tt> - <p>the name to use as the namespace, or NULL use the default namespace </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">New Listing Objects</p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a22e50405d87eb14439239d715a530d6d"></span><tt class="descname">CEPH_RADOS_API int rados_nobjects_list_open(rados_ioctx_t io, rados_list_ctx_t * ctx)</tt></dt>
<dd><p>Start listing objects in a pool</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to list from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ctx</span></tt> - <p>the handle to store list context in </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad67fee7e912ce55c839b57cceb660709"></span><tt class="descname">CEPH_RADOS_API uint32_t rados_nobjects_list_get_pg_hash_position(rados_list_ctx_t ctx)</tt></dt>
<dd><p>Return hash position of iterator, rounded to the current PG</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>current hash position, rounded to the current pg </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">ctx</span></tt> - <p>iterator marking where you are in the listing </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a5a7f2778daff7a4efad775cca61ae651"></span><tt class="descname">CEPH_RADOS_API uint32_t rados_nobjects_list_seek(rados_list_ctx_t ctx, uint32_t pos)</tt></dt>
<dd><p>Reposition object iterator to a different hash position</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>actual (rounded) position we moved to </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">ctx</span></tt> - <p>iterator marking where you are in the listing </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pos</span></tt> - <p>hash position to move to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1adeba815154ac9b24e731a14e04281668"></span><tt class="descname">CEPH_RADOS_API int rados_nobjects_list_next(rados_list_ctx_t ctx, const char ** entry, const char ** key, const char ** nspace)</tt></dt>
<dd><p>Get the next object name and locator in the pool</p>
<p><em>entry and *key are valid until next call to rados_objects_list_</em></p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ENOENT when there are no more objects to list </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">ctx</span></tt> - <p>iterator marking where you are in the listing </p>
</li>
<li><tt class="first docutils literal"><span class="pre">entry</span></tt> - <p>where to store the name of the entry </p>
</li>
<li><tt class="first docutils literal"><span class="pre">key</span></tt> - <p>where to store the object locator (set to NULL to ignore) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">nspace</span></tt> - <p>where to store the object namespace (set to NULL to ignore) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af87da9fc306f53098ed4fe9a5fdfbd84"></span><tt class="descname">CEPH_RADOS_API void rados_nobjects_list_close(rados_list_ctx_t ctx)</tt></dt>
<dd><p>Close the object listing handle.</p>
<p>This should be called when the handle is no longer needed. The handle should not be used after it has been closed.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">ctx</span></tt> - <p>the handle to close </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Deprecated Listing Objects</p>
<p>Older listing objects interface. Please use the new interface. </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4b548b0278369e91dd2a8745874eda65"></span><tt class="descname">CEPH_RADOS_API int rados_objects_list_open(rados_ioctx_t io, rados_list_ctx_t * ctx)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_nobjects_list_open() instead </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2aa03ac4bcce6eebf4df8a13da32b1c6"></span><tt class="descname">CEPH_RADOS_API uint32_t rados_objects_list_get_pg_hash_position(rados_list_ctx_t ctx)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_nobjects_list_get_pg_hash_position() instead </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aed4e351ca1109d5e800c4bcf2ba18911"></span><tt class="descname">CEPH_RADOS_API uint32_t rados_objects_list_seek(rados_list_ctx_t ctx, uint32_t pos)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_nobjects_list_seek() instead </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a70e8fe129975e580dd05ae84806ee0d3"></span><tt class="descname">CEPH_RADOS_API int rados_objects_list_next(rados_list_ctx_t ctx, const char ** entry, const char ** key)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_nobjects_list_next() instead </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af9ca3f347fdc4c535bb9b13965b805a6"></span><tt class="descname">CEPH_RADOS_API void rados_objects_list_close(rados_list_ctx_t ctx)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_nobjects_list_close() instead </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Snapshots</p>
<p>RADOS snapshots are based upon sequence numbers that form a snapshot context. They are pool-specific. The snapshot context consists of the current snapshot sequence number for a pool, and an array of sequence numbers at which snapshots were taken, in descending order. Whenever a snapshot is created or deleted, the snapshot sequence number for the pool is increased. To add a new snapshot, the new snapshot sequence number must be increased and added to the snapshot context.</p>
<p>There are two ways to manage these snapshot contexts:<ol class="arabic simple">
<li>within the RADOS cluster These are called pool snapshots, and store the snapshot context in the OSDMap. These represent a snapshot of all the objects in a pool.</li>
<li>within the RADOS clients These are called self-managed snapshots, and push the responsibility for keeping track of the snapshot context to the clients. For every write, the client must send the snapshot context. In librados, this is accomplished with rados_selfmanaged_snap_set_write_ctx(). These are more difficult to manage, but are restricted to specific objects instead of applying to an entire pool. </li>
</ol>
</p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad51eaaea0ff8775386cb46e8d3482461"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_create(rados_ioctx_t io, const char * snapname)</tt></dt>
<dd><p>Create a pool-wide snapshot</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to snapshot </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapname</span></tt> - <p>the name of the snapshot </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aa7f436d59ceab1779a342770dd33816b"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_remove(rados_ioctx_t io, const char * snapname)</tt></dt>
<dd><p>Delete a pool snapshot</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to delete the snapshot from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapname</span></tt> - <p>which snapshot to delete </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a32f26dfcf00f7d5ad2ece4bea0e549b9"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_rollback(rados_ioctx_t io, const char * oid, const char * snapname)</tt></dt>
<dd><p>Rollback an object to a pool snapshot</p>
<p>The contents of the object will be the same as when the snapshot was taken.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool in which the object is stored </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object to rollback </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapname</span></tt> - <p>which snapshot to rollback to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aba0559b2cf1d82b9527507788a994f78"></span><tt class="descname">CEPH_RADOS_API int rados_rollback(rados_ioctx_t io, const char * oid, const char * snapname)</tt></dt>
<dd><p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Deprecated: Use rados_ioctx_snap_rollback() instead </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac0952bef2b12373b2cb7c86d59131fc9"></span><tt class="descname">CEPH_RADOS_API void rados_ioctx_snap_set_read(rados_ioctx_t io, rados_snap_t snap)</tt></dt>
<dd><p>Set the snapshot from which reads are performed.</p>
<p>Subsequent reads will return data as it was at the time of that snapshot.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to change </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snap</span></tt> - <p>the id of the snapshot to set, or LIBRADOS_SNAP_HEAD for no snapshot (i.e. normal operation) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a0c1349c0fa36033abac30052bee2a8f3"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_selfmanaged_snap_create(rados_ioctx_t io, rados_snap_t * snapid)</tt></dt>
<dd><p>Allocate an ID for a self-managed snapshot</p>
<p>Get a unique ID to put in the snaphot context to create a snapshot. A clone of an object is not created until a write with the new snapshot context is completed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool in which the snapshot will exist </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapid</span></tt> - <p>where to store the newly allocated snapshot ID </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a82b319c2e959e354e9f4065111b3451d"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_selfmanaged_snap_remove(rados_ioctx_t io, rados_snap_t snapid)</tt></dt>
<dd><p>Remove a self-managed snapshot</p>
<p>This increases the snapshot sequence number, which will cause snapshots to be removed lazily.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool in which the snapshot will exist </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapid</span></tt> - <p>where to store the newly allocated snapshot ID </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ada1171cf52b6b37571cc5d8519da489b"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_selfmanaged_snap_rollback(rados_ioctx_t io, const char * oid, rados_snap_t snapid)</tt></dt>
<dd><p>Rollback an object to a self-managed snapshot</p>
<p>The contents of the object will be the same as when the snapshot was taken.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool in which the object is stored </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object to rollback </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snapid</span></tt> - <p>which snapshot to rollback to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a167b88a0cccb06c553e786cf1190ba22"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_selfmanaged_snap_set_write_ctx(rados_ioctx_t io, rados_snap_t seq, rados_snap_t * snaps, int num_snaps)</tt></dt>
<dd><p>Set the snapshot context for use when writing to objects</p>
<p>This is stored in the io context, and applies to all future writes.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-EINVAL if snaps are not in descending order </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to change </p>
</li>
<li><tt class="first docutils literal"><span class="pre">seq</span></tt> - <p>the newest snapshot sequence number for the pool </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snaps</span></tt> - <p>array of snapshots in sorted by descending id </p>
</li>
<li><tt class="first docutils literal"><span class="pre">num_snaps</span></tt> - <p>how many snaphosts are in the snaps array </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a07cbdeb89d3bb57712e2efd9a276b216"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_list(rados_ioctx_t io, rados_snap_t * snaps, int maxlen)</tt></dt>
<dd><p>List all the ids of pool snapshots</p>
<p>If the output array does not have enough space to fit all the snapshots, -ERANGE is returned and the caller should retry with a larger array.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>number of snapshots on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE is returned if the snaps array is too short </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">snaps</span></tt> - <p>where to store the results </p>
</li>
<li><tt class="first docutils literal"><span class="pre">maxlen</span></tt> - <p>the number of rados_snap_t that fit in the snaps array </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a0e3605c1e6ec7e1f74d89e6f5cb6c780"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_lookup(rados_ioctx_t io, const char * name, rados_snap_t * id)</tt></dt>
<dd><p>Get the id of a pool snapshot</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the snapshot to find </p>
</li>
<li><tt class="first docutils literal"><span class="pre">id</span></tt> - <p>where to store the result </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a5c4dd3bc1af3e693559cdd77677d0367"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_get_name(rados_ioctx_t io, rados_snap_t id, char * name, int maxlen)</tt></dt>
<dd><p>Get the name of a pool snapshot</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE if the name array is too small </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">id</span></tt> - <p>the snapshot to find </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>where to store the result </p>
</li>
<li><tt class="first docutils literal"><span class="pre">maxlen</span></tt> - <p>the size of the name array </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a43e4b3c47a04540b9dae9526f51446b2"></span><tt class="descname">CEPH_RADOS_API int rados_ioctx_snap_get_stamp(rados_ioctx_t io, rados_snap_t id, time_t * t)</tt></dt>
<dd><p>Find when a pool snapshot occurred</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the snapshot was taken in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">id</span></tt> - <p>the snapshot to lookup </p>
</li>
<li><tt class="first docutils literal"><span class="pre">t</span></tt> - <p>where to store the result </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Synchronous I/O</p>
<p>Writes are replicated to a number of OSDs based on the configuration of the pool they are in. These write functions block until data is in memory on all replicas of the object they&#8217;re writing to - they are equivalent to doing the corresponding asynchronous write, and the calling rados_ioctx_wait_for_complete(). For greater data safety, use the asynchronous functions and rados_aio_wait_for_safe(). </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af03c0d22c25c1473d29bc418a16f2131"></span><tt class="descname">CEPH_RADOS_API uint64_t rados_get_last_version(rados_ioctx_t io)</tt></dt>
<dd><p>Return the version of the last object read or written to.</p>
<p>This exposes the internal version number of the last object read or written via this io context</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>last read or written object version </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context to check </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a6c14a0314a6bed507dd815183598376b"></span><tt class="descname">CEPH_RADOS_API int rados_write(rados_ioctx_t io, const char * oid, const char * buf, size_t len, uint64_t off)</tt></dt>
<dd><p>Write <em>len</em> bytes from <em>buf</em> into the <em>oid</em> object, starting at offset <em>off</em>. The value of <em>len</em> must be &lt;= UINT_MAX/2.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This will never return a positive value not equal to len. </dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context in which the write will occur </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of the data, in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">off</span></tt> - <p>byte offset in the object to begin writing at </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a8dd9ea7a01a033f6d41ed4af3c801b02"></span><tt class="descname">CEPH_RADOS_API int rados_write_full(rados_ioctx_t io, const char * oid, const char * buf, size_t len)</tt></dt>
<dd><p>Write <em>len</em> bytes from <em>buf</em> into the <em>oid</em> object. The value of <em>len</em> must be &lt;= UINT_MAX/2.</p>
<p>The object is filled with the provided data. If the object exists, it is atomically truncated and then written.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the io context in which the write will occur </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>data to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of the data, in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a074680018d0c0fc2842d65ba0c9b3936"></span><tt class="descname">CEPH_RADOS_API int rados_clone_range(rados_ioctx_t io, const char * dst, uint64_t dst_off, const char * src, uint64_t src_off, size_t len)</tt></dt>
<dd><p>Efficiently copy a portion of one object to another</p>
<p>If the underlying filesystem on the OSD supports it, this will be a copy-on-write clone.</p>
<p>The src and dest objects must be in the same pg. To ensure this, the io context should have a locator key set (see rados_ioctx_locator_set_key()).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which the data is cloned </p>
</li>
<li><tt class="first docutils literal"><span class="pre">dst</span></tt> - <p>the name of the destination object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">dst_off</span></tt> - <p>the offset within the destination object (in bytes) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">src</span></tt> - <p>the name of the source object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">src_off</span></tt> - <p>the offset within the source object (in bytes) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>how much data to copy </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a540fd1ea20ff7c54bab80f240fcc7e4f"></span><tt class="descname">CEPH_RADOS_API int rados_append(rados_ioctx_t io, const char * oid, const char * buf, size_t len)</tt></dt>
<dd><p>Append <em>len</em> bytes from <em>buf</em> into the <em>oid</em> object. The value of <em>len</em> must be &lt;= UINT_MAX/2.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>the data to append </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buf (in bytes) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1adba16f73ecb0aa12ed9773e2faa2aeef"></span><tt class="descname">CEPH_RADOS_API int rados_read(rados_ioctx_t io, const char * oid, char * buf, size_t len, uint64_t off)</tt></dt>
<dd><p>Read data from an object</p>
<p>The io context determines the snapshot to read from, if any was set by rados_ioctx_snap_set_read().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>number of bytes read on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to perform the read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to store the results </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the number of bytes to read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">off</span></tt> - <p>the offset to start reading from in the object </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a7f798a662c135887fa8d2c615f7ddb24"></span><tt class="descname">CEPH_RADOS_API int rados_remove(rados_ioctx_t io, const char * oid)</tt></dt>
<dd><p>Delete an object</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This does not delete any snapshots of the object.</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool to delete the object from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object to delete </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a9d097d3def2362959a3af634076977ee"></span><tt class="descname">CEPH_RADOS_API int rados_trunc(rados_ioctx_t io, const char * oid, uint64_t size)</tt></dt>
<dd><p>Resize an object</p>
<p>If this enlarges the object, the new area is logically filled with zeroes. If this shrinks the object, the excess data is removed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to truncate </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">size</span></tt> - <p>the new size of the object in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Xattrs</p>
<p>Extended attributes are stored as extended attributes on the files representing an object on the OSDs. Thus, they have the same limitations as the underlying filesystem. On ext4, this means that the total data stored in xattrs cannot exceed 4KB. </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1a42661f155dfdfc25573904f9fe8749"></span><tt class="descname">CEPH_RADOS_API int rados_getxattr(rados_ioctx_t io, const char * o, const char * name, char * buf, size_t len)</tt></dt>
<dd><p>Get the value of an extended attribute on an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>length of xattr value on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which the attribute is read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>which extended attribute to read </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to store the result </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>size of buf in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a68c320a11946a5e3de8a07f1f63b0663"></span><tt class="descname">CEPH_RADOS_API int rados_setxattr(rados_ioctx_t io, const char * o, const char * name, const char * buf, size_t len)</tt></dt>
<dd><p>Set an extended attribute on an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which xattr is set </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>which extended attribute to set </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>what to store in the xattr </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the number of bytes in buf </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3ce9090dfd315a5489e66f6e1babe4ed"></span><tt class="descname">CEPH_RADOS_API int rados_rmxattr(rados_ioctx_t io, const char * o, const char * name)</tt></dt>
<dd><p>Delete an extended attribute from an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to delete the xattr </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>which xattr to delete </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3cd7a2f9aabdff37d3feaba25adb6001"></span><tt class="descname">CEPH_RADOS_API int rados_getxattrs(rados_ioctx_t io, const char * oid, rados_xattrs_iter_t * iter)</tt></dt>
<dd><p>Start iterating over xattrs on an object.</p>
<p><dl class="docutils">
<dt><strong>Post</strong></dt>
<dd>iter is a valid iterator</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to list xattrs </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>where to store the iterator </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab9fe9f160d6d11441ceb4570d56c8630"></span><tt class="descname">CEPH_RADOS_API int rados_getxattrs_next(rados_xattrs_iter_t iter, const char ** name, const char ** val, size_t * len)</tt></dt>
<dd><p>Get the next xattr on the object</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>iter is a valid iterator</dd>
<dt><strong>Post</strong></dt>
<dd>name is the NULL-terminated name of the next xattr, and val contains the value of the xattr, which is of length len. If the end of the list has been reached, name and val are NULL, and len is 0.</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>iterator to advance </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>where to store the name of the next xattr </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val</span></tt> - <p>where to store the value of the next xattr </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the number of bytes in val </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1abbf5f8bb4a12a188bfa122d5ec030824"></span><tt class="descname">CEPH_RADOS_API void rados_getxattrs_end(rados_xattrs_iter_t iter)</tt></dt>
<dd><p>Close the xattr iterator.</p>
<p>iter should not be used after this is called.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>the iterator to close </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Hints</p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1abd78efb9532478e17b10ccbc971b91e7"></span><tt class="descname">CEPH_RADOS_API int rados_set_alloc_hint(rados_ioctx_t io, const char * o, uint64_t expected_object_size, uint64_t expected_write_size)</tt></dt>
<dd><p>Set allocation hint for an object</p>
<p>This is an advisory operation, it will always succeed (as if it was submitted with a LIBRADOS_OP_FLAG_FAILOK flag set) and is not guaranteed to do anything on the backend.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the pool the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">expected_object_size</span></tt> - <p>expected size of the object, in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">expected_write_size</span></tt> - <p>expected size of writes to the object, in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Object Operations</p>
<p>A single rados operation can do multiple operations on one object atomicly. The whole operation will suceed or fail, and no partial results will be visible.</p>
<p>Operations may be either reads, which can return data, or writes, which cannot. The effects of writes are applied and visible all at once, so an operation that sets an xattr and then checks its value will not see the updated value. </p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1af1a3dddf1756d6ffdb48417b63cc72d6"></span><tt class="descname">CEPH_RADOS_API rados_write_op_t rados_create_write_op(void)</tt></dt>
<dd><p>Create a new rados_write_op_t write operation. This will store all actions to be performed atomically. You must call rados_release_write_op when you are finished with it.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>non-NULL on success, NULL on memory allocation error. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4fe6fc320c2658c6c3820a2d0e39fb2d"></span><tt class="descname">CEPH_RADOS_API void rados_release_write_op(rados_write_op_t write_op)</tt></dt>
<dd><p>Free a rados_write_op_t, must be called when you&#8217;re done with it. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to deallocate, created with rados_create_write_op </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3cd5c699edf254c1d35f05276a1c8c6f"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_set_flags(rados_write_op_t write_op, int flags)</tt></dt>
<dd><p>Set flags for the last operation added to this write_op. At least one op must have been added to the write_op. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>see librados.h constants beginning with LIBRADOS_OP_FLAG </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a459637c40a24a01ba53f9d74d74c3d25"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_assert_exists(rados_write_op_t write_op)</tt></dt>
<dd><p>Ensure that the object exists before writing <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3cbd03eef7f3b8004cabdb96d0ea8e1b"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_assert_version(rados_write_op_t write_op, uint64_t ver)</tt></dt>
<dd><p>Ensure that the object exists and that its internal version number is equal to &#8220;ver&#8221; before writing. &#8220;ver&#8221; should be a version number previously obtained with rados_get_last_version().<ul class="simple">
<li>If the object&#8217;s version is greater than the asserted version then rados_write_op_operate will return -ERANGE instead of executing the op.</li>
<li>If the object&#8217;s version is less than the asserted version then rados_write_op_operate will return -EOVERFLOW instead of executing the op. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ver</span></tt> - <p>object version number </p>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1afbb02f70537541e97839f41d8c5966cb"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_cmpxattr(rados_write_op_t write_op, const char * name, uint8_t comparison_operator, const char * value, size_t value_len)</tt></dt>
<dd><p>Ensure that given xattr satisfies comparison. If the comparison is not satisfied, the return code of the operation will be -ECANCELED <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>name of the xattr to look up </p>
</li>
<li><tt class="first docutils literal"><span class="pre">comparison_operator</span></tt> - <p>currently undocumented, look for LIBRADOS_CMPXATTR_OP_EQ in librados.h </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value</span></tt> - <p>buffer to compare actual xattr value to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value_len</span></tt> - <p>length of buffer to compare actual xattr value to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ae438d976007b3416d0bbc730d855f645"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_omap_cmp(rados_write_op_t write_op, const char * key, uint8_t comparison_operator, const char * val, size_t val_len, int * prval)</tt></dt>
<dd><p>Ensure that the an omap value satisfies a comparison, with the supplied value on the right hand side (i.e. for OP_LT, the comparison is actual_value &lt; value.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">key</span></tt> - <p>which omap value to compare </p>
</li>
<li><tt class="first docutils literal"><span class="pre">comparison_operator</span></tt> - <p>one of LIBRADOS_CMPXATTR_OP_EQ, LIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val</span></tt> - <p>value to compare with </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val_len</span></tt> - <p>length of value in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1acc58681b93def974e40fe49a05a291d7"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_setxattr(rados_write_op_t write_op, const char * name, const char * value, size_t value_len)</tt></dt>
<dd><p>Set an xattr <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>name of the xattr </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value</span></tt> - <p>buffer to set xattr to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value_len</span></tt> - <p>length of buffer to set xattr to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a99388a92b5c0de558fcf994683fe4303"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_rmxattr(rados_write_op_t write_op, const char * name)</tt></dt>
<dd><p>Remove an xattr <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>name of the xattr to remove </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a871253b998c0bf4a0d68f31b51e90b59"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_create(rados_write_op_t write_op, int exclusive, const char * category)</tt></dt>
<dd><p>Create the object <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">exclusive</span></tt> - <p>set to either LIBRADOS_CREATE_EXCLUSIVE or LIBRADOS_CREATE_IDEMPOTENT will error if the object already exists. </p>
</li>
<li><tt class="first docutils literal"><span class="pre">category</span></tt> - <p>category string (DEPRECATED, HAS NO EFFECT) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a87fda9540d2afb70031cdc7bf884e6d0"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_write(rados_write_op_t write_op, const char * buffer, size_t len, uint64_t offset)</tt></dt>
<dd><p>Write to offset <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">offset</span></tt> - <p>offset to write to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buffer</span></tt> - <p>bytes to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1afff830c06c309f4caff26edd976d362c"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_write_full(rados_write_op_t write_op, const char * buffer, size_t len)</tt></dt>
<dd><p>Write whole object, atomically replacing it. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buffer</span></tt> - <p>bytes to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a279d9af15f591158734f8937cc188011"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_append(rados_write_op_t write_op, const char * buffer, size_t len)</tt></dt>
<dd><p>Append to end of object. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buffer</span></tt> - <p>bytes to write </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab3c2aacf0028c76b91ef77ed1d3767b6"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_remove(rados_write_op_t write_op)</tt></dt>
<dd><p>Remove object <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aaf7ed5ece0b071f94f82b54daffdaae5"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_truncate(rados_write_op_t write_op, uint64_t offset)</tt></dt>
<dd><p>Truncate an object <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">offset</span></tt> - <p>Offset to truncate to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ae24820c042da2d7d18a0a08e87b9e4a0"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_zero(rados_write_op_t write_op, uint64_t offset, uint64_t len)</tt></dt>
<dd><p>Zero part of an object <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">offset</span></tt> - <p>Offset to zero </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length to zero </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4a5e172333ae4886b913f8189a56209e"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_exec(rados_write_op_t write_op, const char * cls, const char * method, const char * in_buf, size_t in_len, int * prval)</tt></dt>
<dd><p>Execute an OSD class method on an object See rados_exec() for general description.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cls</span></tt> - <p>the name of the class </p>
</li>
<li><tt class="first docutils literal"><span class="pre">method</span></tt> - <p>the name of the method </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_buf</span></tt> - <p>where to find input </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_len</span></tt> - <p>length of in_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from the method </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1adfed001930bd8fa7baf874849b784a4d"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_omap_set(rados_write_op_t write_op, char const *const * keys, char const *const * vals, const size_t * lens, size_t num)</tt></dt>
<dd><p>Set key/value pairs on an object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">keys</span></tt> - <p>array of null-terminated char arrays representing keys to set </p>
</li>
<li><tt class="first docutils literal"><span class="pre">vals</span></tt> - <p>array of pointers to values to set </p>
</li>
<li><tt class="first docutils literal"><span class="pre">lens</span></tt> - <p>array of lengths corresponding to each value </p>
</li>
<li><tt class="first docutils literal"><span class="pre">num</span></tt> - <p>number of key/value pairs to set </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab67e77fa008171af93d6449f87451342"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_omap_rm_keys(rados_write_op_t write_op, char const *const * keys, size_t keys_len)</tt></dt>
<dd><p>Remove key/value pairs from an object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">keys</span></tt> - <p>array of null-terminated char arrays representing keys to remove </p>
</li>
<li><tt class="first docutils literal"><span class="pre">keys_len</span></tt> - <p>number of key/value pairs to remove </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3ccb37b35d552479d894897804532957"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_omap_clear(rados_write_op_t write_op)</tt></dt>
<dd><p>Remove all key/value pairs from an object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a10d567a2123f01032d653bfeae40dcc3"></span><tt class="descname">CEPH_RADOS_API void rados_write_op_set_alloc_hint(rados_write_op_t write_op, uint64_t expected_object_size, uint64_t expected_write_size)</tt></dt>
<dd><p>Set allocation hint for an object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">expected_object_size</span></tt> - <p>expected size of the object, in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">expected_write_size</span></tt> - <p>expected size of writes to the object, in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad8ed722b0defa7d4f6f8bd7b2329680a"></span><tt class="descname">CEPH_RADOS_API int rados_write_op_operate(rados_write_op_t write_op, rados_ioctx_t io, const char * oid, time_t * mtime, int flags)</tt></dt>
<dd><p>Perform a write operation synchronously <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to perform </p>
</li>
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the ioctx that the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the object id </p>
</li>
<li><tt class="first docutils literal"><span class="pre">mtime</span></tt> - <p>the time to set the mtime to, NULL for the current time </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>flags to apply to the entire operation (LIBRADOS_OPERATION_*) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a509289b47a1b11d70465cd5158731354"></span><tt class="descname">CEPH_RADOS_API int rados_aio_write_op_operate(rados_write_op_t write_op, rados_ioctx_t io, rados_completion_t completion, const char * oid, time_t * mtime, int flags)</tt></dt>
<dd><p>Perform a write operation asynchronously <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">write_op</span></tt> - <p>operation to perform </p>
</li>
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the ioctx that the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when operation has been attempted </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the object id </p>
</li>
<li><tt class="first docutils literal"><span class="pre">mtime</span></tt> - <p>the time to set the mtime to, NULL for the current time </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>flags to apply to the entire operation (LIBRADOS_OPERATION_*) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a36fb813c7253dd8af8ff063bc6101412"></span><tt class="descname">CEPH_RADOS_API rados_read_op_t rados_create_read_op(void)</tt></dt>
<dd><p>Create a new rados_read_op_t write operation. This will store all actions to be performed atomically. You must call rados_release_read_op when you are finished with it (after it completes, or you decide not to send it in the first place).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>non-NULL on success, NULL on memory allocation error. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a46da900e0e90ace24ffc63539f86241e"></span><tt class="descname">CEPH_RADOS_API void rados_release_read_op(rados_read_op_t read_op)</tt></dt>
<dd><p>Free a rados_read_op_t, must be called when you&#8217;re done with it. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to deallocate, created with rados_create_read_op </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1afe7176da810543a5eb538222f942962f"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_set_flags(rados_read_op_t read_op, int flags)</tt></dt>
<dd><p>Set flags for the last operation added to this read_op. At least one op must have been added to the read_op. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>see librados.h constants beginning with LIBRADOS_OP_FLAG </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a8cdac9f1af075afcd19dfcc7d7f7bfc8"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_assert_exists(rados_read_op_t read_op)</tt></dt>
<dd><p>Ensure that the object exists before reading <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2ff9a1cb23a586796efa7f7d91449643"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_assert_version(rados_read_op_t read_op, uint64_t ver)</tt></dt>
<dd><p>Ensure that the object exists and that its internal version number is equal to &#8220;ver&#8221; before reading. &#8220;ver&#8221; should be a version number previously obtained with rados_get_last_version().<ul class="simple">
<li>If the object&#8217;s version is greater than the asserted version then rados_read_op_operate will return -ERANGE instead of executing the op.</li>
<li>If the object&#8217;s version is less than the asserted version then rados_read_op_operate will return -EOVERFLOW instead of executing the op. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">ver</span></tt> - <p>object version number </p>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3eb67a54e426d4d1ffc1b8f21c5cfce0"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_cmpxattr(rados_read_op_t read_op, const char * name, uint8_t comparison_operator, const char * value, size_t value_len)</tt></dt>
<dd><p>Ensure that the an xattr satisfies a comparison If the comparison is not satisfied, the return code of the operation will be -ECANCELED <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>name of the xattr to look up </p>
</li>
<li><tt class="first docutils literal"><span class="pre">comparison_operator</span></tt> - <p>currently undocumented, look for LIBRADOS_CMPXATTR_OP_EQ in librados.h </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value</span></tt> - <p>buffer to compare actual xattr value to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">value_len</span></tt> - <p>length of buffer to compare actual xattr value to </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1abe53268cfc8f01c5208265391390acd7"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_getxattrs(rados_read_op_t read_op, rados_xattrs_iter_t * iter, int * prval)</tt></dt>
<dd><p>Start iterating over xattrs on an object.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>where to store the iterator </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value of this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a9d9c8a790a67cc917da5b707f56b7b68"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_omap_cmp(rados_read_op_t read_op, const char * key, uint8_t comparison_operator, const char * val, size_t val_len, int * prval)</tt></dt>
<dd><p>Ensure that the an omap value satisfies a comparison, with the supplied value on the right hand side (i.e. for OP_LT, the comparison is actual_value &lt; value.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">key</span></tt> - <p>which omap value to compare </p>
</li>
<li><tt class="first docutils literal"><span class="pre">comparison_operator</span></tt> - <p>one of LIBRADOS_CMPXATTR_OP_EQ, LIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val</span></tt> - <p>value to compare with </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val_len</span></tt> - <p>length of value in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac306f89b05d84ed0c83342a60c746ca7"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_stat(rados_read_op_t read_op, uint64_t * psize, time_t * pmtime, int * prval)</tt></dt>
<dd><p>Get object size and mtime <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">psize</span></tt> - <p>where to store object size </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pmtime</span></tt> - <p>where to store modification time </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value of this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aa67f45909d4132b50c8407364729aa7a"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_read(rados_read_op_t read_op, uint64_t offset, size_t len, char * buffer, size_t * bytes_read, int * prval)</tt></dt>
<dd><p>Read bytes from offset into buffer.</p>
<p>prlen will be filled with the number of bytes read if successful. A short read can only occur if the read reaches the end of the object.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">offset</span></tt> - <p>offset to read from </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>length of buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buffer</span></tt> - <p>where to put the data </p>
</li>
<li><tt class="first docutils literal"><span class="pre">bytes_read</span></tt> - <p>where to store the number of bytes read by this action </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value of this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a1f87378777c8b7cc7bab5add93055a74"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_exec(rados_read_op_t read_op, const char * cls, const char * method, const char * in_buf, size_t in_len, char ** out_buf, size_t * out_len, int * prval)</tt></dt>
<dd><p>Execute an OSD class method on an object See rados_exec() for general description.</p>
<p>The output buffer is allocated on the heap; the caller is expected to release that memory with rados_buffer_free(). The buffer and length pointers can all be NULL, in which case they are not filled in.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cls</span></tt> - <p>the name of the class </p>
</li>
<li><tt class="first docutils literal"><span class="pre">method</span></tt> - <p>the name of the method </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_buf</span></tt> - <p>where to find input </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_len</span></tt> - <p>length of in_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">out_buf</span></tt> - <p>where to put librados-allocated output buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">out_len</span></tt> - <p>length of out_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from the method </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1aaab5404d3a37b629e5bc1f5ddd257912"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_exec_user_buf(rados_read_op_t read_op, const char * cls, const char * method, const char * in_buf, size_t in_len, char * out_buf, size_t out_len, size_t * used_len, int * prval)</tt></dt>
<dd><p>Execute an OSD class method on an object See rados_exec() for general description.</p>
<p>If the output buffer is too small, prval will be set to -ERANGE and used_len will be 0.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cls</span></tt> - <p>the name of the class </p>
</li>
<li><tt class="first docutils literal"><span class="pre">method</span></tt> - <p>the name of the method </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_buf</span></tt> - <p>where to find input </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_len</span></tt> - <p>length of in_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">out_buf</span></tt> - <p>user-provided buffer to read into </p>
</li>
<li><tt class="first docutils literal"><span class="pre">out_len</span></tt> - <p>length of out_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">used_len</span></tt> - <p>where to store the number of bytes read into out_buf </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from the method </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ac5e2fcdee454abb807375f55c1520843"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_omap_get_vals(rados_read_op_t read_op, const char * start_after, const char * filter_prefix, uint64_t max_return, rados_omap_iter_t * iter, int * prval)</tt></dt>
<dd><p>Start iterating over key/value pairs on an object.</p>
<p>They will be returned sorted by key.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">start_after</span></tt> - <p>list keys starting after start_after </p>
</li>
<li><tt class="first docutils literal"><span class="pre">filter_prefix</span></tt> - <p>list only keys beginning with filter_prefix </p>
</li>
<li><tt class="first docutils literal"><span class="pre">max_return</span></tt> - <p>list no more than max_return key/value pairs </p>
</li>
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>where to store the iterator </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a4afbb579f63a83c360fd66d948aac6a3"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_omap_get_keys(rados_read_op_t read_op, const char * start_after, uint64_t max_return, rados_omap_iter_t * iter, int * prval)</tt></dt>
<dd><p>Start iterating over keys on an object.</p>
<p>They will be returned sorted by key, and the iterator will fill in NULL for all values if specified.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">start_after</span></tt> - <p>list keys starting after start_after </p>
</li>
<li><tt class="first docutils literal"><span class="pre">max_return</span></tt> - <p>list no more than max_return keys </p>
</li>
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>where to store the iterator </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a24047194f483c33641575336aa306a65"></span><tt class="descname">CEPH_RADOS_API void rados_read_op_omap_get_vals_by_keys(rados_read_op_t read_op, char const *const * keys, size_t keys_len, rados_omap_iter_t * iter, int * prval)</tt></dt>
<dd><p>Start iterating over specific key/value pairs</p>
<p>They will be returned sorted by key.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to add this action to </p>
</li>
<li><tt class="first docutils literal"><span class="pre">keys</span></tt> - <p>array of pointers to null-terminated keys to get </p>
</li>
<li><tt class="first docutils literal"><span class="pre">keys_len</span></tt> - <p>the number of strings in keys </p>
</li>
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>where to store the iterator </p>
</li>
<li><tt class="first docutils literal"><span class="pre">prval</span></tt> - <p>where to store the return value from this action </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a3178db23e0b3ed2ed5a6b715d6343e03"></span><tt class="descname">CEPH_RADOS_API int rados_read_op_operate(rados_read_op_t read_op, rados_ioctx_t io, const char * oid, int flags)</tt></dt>
<dd><p>Perform a read operation synchronously <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to perform </p>
</li>
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the ioctx that the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the object id </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>flags to apply to the entire operation (LIBRADOS_OPERATION_*) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad3289c5789ff988b5b10b545dbc03afa"></span><tt class="descname">CEPH_RADOS_API int rados_aio_read_op_operate(rados_read_op_t read_op, rados_ioctx_t io, rados_completion_t completion, const char * oid, int flags)</tt></dt>
<dd><p>Perform a read operation asynchronously <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">read_op</span></tt> - <p>operation to perform </p>
</li>
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the ioctx that the object is in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">completion</span></tt> - <p>what to do when operation has been attempted </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the object id </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>flags to apply to the entire operation (LIBRADOS_OPERATION_*) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="CEPH_OSD_TMAP_HDR">
<span class="target" id="Cephlibrados_8h_1a7374c886c3d189e22dab99e8e97b1c4a"></span><tt class="descname">CEPH_OSD_TMAP_HDR</tt><a class="headerlink" href="#CEPH_OSD_TMAP_HDR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="CEPH_OSD_TMAP_SET">
<span class="target" id="Cephlibrados_8h_1ada41defa6d369f2e04ca53fc40754a37"></span><tt class="descname">CEPH_OSD_TMAP_SET</tt><a class="headerlink" href="#CEPH_OSD_TMAP_SET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="CEPH_OSD_TMAP_CREATE">
<span class="target" id="Cephlibrados_8h_1a0ba9335b21cd46e0cb4b03bf972f73e9"></span><tt class="descname">CEPH_OSD_TMAP_CREATE</tt><a class="headerlink" href="#CEPH_OSD_TMAP_CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="CEPH_OSD_TMAP_RM">
<span class="target" id="Cephlibrados_8h_1a553821d1fdb398b952d8595b2ea7939a"></span><tt class="descname">CEPH_OSD_TMAP_RM</tt><a class="headerlink" href="#CEPH_OSD_TMAP_RM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_VER_MAJOR">
<span class="target" id="Cephlibrados_8h_1a0e0a428e7c02e984c30aaf54631b9179"></span><tt class="descname">LIBRADOS_VER_MAJOR</tt><a class="headerlink" href="#LIBRADOS_VER_MAJOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_VER_MINOR">
<span class="target" id="Cephlibrados_8h_1a6921c0c5fa48340c3b43d986b924789d"></span><tt class="descname">LIBRADOS_VER_MINOR</tt><a class="headerlink" href="#LIBRADOS_VER_MINOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_VER_EXTRA">
<span class="target" id="Cephlibrados_8h_1a1365154562de601650c9195216f47597"></span><tt class="descname">LIBRADOS_VER_EXTRA</tt><a class="headerlink" href="#LIBRADOS_VER_EXTRA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_VERSION">
<span class="target" id="Cephlibrados_8h_1a6a37ef77a4f8ab9670d137329fd9ec3d"></span><tt class="descname">LIBRADOS_VERSION</tt><big>(</big>maj, min, extra<big>)</big><a class="headerlink" href="#LIBRADOS_VERSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_VERSION_CODE">
<span class="target" id="Cephlibrados_8h_1a5931a8379cebc7eed36f7146cfa1afa2"></span><tt class="descname">LIBRADOS_VERSION_CODE</tt><a class="headerlink" href="#LIBRADOS_VERSION_CODE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_SUPPORTS_WATCH">
<span class="target" id="Cephlibrados_8h_1a49279ff58e94fe7bc89cf2a9561abc49"></span><tt class="descname">LIBRADOS_SUPPORTS_WATCH</tt><a class="headerlink" href="#LIBRADOS_SUPPORTS_WATCH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_LOCK_FLAG_RENEW">
<span class="target" id="Cephlibrados_8h_1a8422e60e2574925bf18537aac98fff00"></span><tt class="descname">LIBRADOS_LOCK_FLAG_RENEW</tt><a class="headerlink" href="#LIBRADOS_LOCK_FLAG_RENEW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_CREATE_EXCLUSIVE">
<span class="target" id="Cephlibrados_8h_1ac1f2fb141026970b30b31c6b510c40ec"></span><tt class="descname">LIBRADOS_CREATE_EXCLUSIVE</tt><a class="headerlink" href="#LIBRADOS_CREATE_EXCLUSIVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_CREATE_IDEMPOTENT">
<span class="target" id="Cephlibrados_8h_1a9d95de9eadd0c19d2d882207f68cd087"></span><tt class="descname">LIBRADOS_CREATE_IDEMPOTENT</tt><a class="headerlink" href="#LIBRADOS_CREATE_IDEMPOTENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="CEPH_RADOS_API">
<span class="target" id="Cephlibrados_8h_1aafc8385a5a2f57cee390b248a5edb1ee"></span><tt class="descname">CEPH_RADOS_API</tt><a class="headerlink" href="#CEPH_RADOS_API" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_SNAP_HEAD">
<span class="target" id="Cephlibrados_8h_1a4f7b1b8bdc639f1bc8d66327d53977bd"></span><tt class="descname">LIBRADOS_SNAP_HEAD</tt><a class="headerlink" href="#LIBRADOS_SNAP_HEAD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="LIBRADOS_SNAP_DIR">
<span class="target" id="Cephlibrados_8h_1a94024e58d58fb0a06c184e5b1e725ccd"></span><tt class="descname">LIBRADOS_SNAP_DIR</tt><a class="headerlink" href="#LIBRADOS_SNAP_DIR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="rados_t">
<span class="target" id="Cephlibrados_8h_1abda043338e76ae05b784cc194ff15cfa"></span><em class="property">typedef </em><tt class="descname">rados_t</tt><a class="headerlink" href="#rados_t" title="Permalink to this definition">¶</a></dt>
<dd><p>A handle for interacting with a RADOS cluster. It encapsulates all RADOS client configuration, including username, key for authentication, logging, and debugging. Talking different clusters  or to the same cluster with different users  requires different cluster handles. </p>
</dd></dl>

<dl class="type">
<dt id="rados_config_t__voidP">
<span class="target" id="Cephlibrados_8h_1ab9b166c127d67cd6a2795e21f70c23e1"></span><em class="property">typedef </em>void* <tt class="descname">rados_config_t</tt><a class="headerlink" href="#rados_config_t__voidP" title="Permalink to this definition">¶</a></dt>
<dd><p>rados_config_t</p>
<p>A handle for the ceph configuration context for the rados_t cluster instance. This can be used to share configuration context/state (e.g., logging configuration) between librados instance.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>The config context does not have independent reference counting. As such, a rados_config_t handle retrieved from a given rados_t is only valid as long as that rados_t. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="rados_ioctx_t">
<span class="target" id="Cephlibrados_8h_1aa892568c6a8b4f1c07785b228014e3e3"></span><em class="property">typedef </em><tt class="descname">rados_ioctx_t</tt><a class="headerlink" href="#rados_ioctx_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An io context encapsulates a few settings for all I/O operations done on it:<ul class="simple">
<li>pool - set when the io context is created (see rados_ioctx_create())</li>
<li>snapshot context for writes (see rados_ioctx_selfmanaged_snap_set_write_ctx())</li>
<li>snapshot id to read from (see rados_ioctx_snap_set_read())</li>
<li>object locator for all single-object operations (see rados_ioctx_locator_set_key())</li>
<li>namespace for all single-object operations (see rados_ioctx_set_namespace()). Set to LIBRADOS_ALL_NSPACES before rados_nobjects_list_open() will list all objects in all namespaces.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Changing any of these settings is not thread-safe - librados users must synchronize any of these changes on their own, or use separate io contexts for each thread </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="rados_list_ctx_t">
<span class="target" id="Cephlibrados_8h_1ad0584c3ac7134ce95522fe9cf0505c52"></span><em class="property">typedef </em><tt class="descname">rados_list_ctx_t</tt><a class="headerlink" href="#rados_list_ctx_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator for listing the objects in a pool. Used with rados_nobjects_list_open(), rados_nobjects_list_next(), and rados_nobjects_list_close(). </p>
</dd></dl>

<dl class="type">
<dt id="rados_snap_t">
<span class="target" id="Cephlibrados_8h_1ac997570481a967558a27892037ed0f40"></span><em class="property">typedef </em><tt class="descname">rados_snap_t</tt><a class="headerlink" href="#rados_snap_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of a snapshot. </p>
</dd></dl>

<dl class="type">
<dt id="rados_xattrs_iter_t">
<span class="target" id="Cephlibrados_8h_1a44416b1d487862521589e0ead757fe3c"></span><em class="property">typedef </em><tt class="descname">rados_xattrs_iter_t</tt><a class="headerlink" href="#rados_xattrs_iter_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator for listing extended attrbutes on an object. Used with rados_getxattrs(), rados_getxattrs_next(), and rados_getxattrs_end(). </p>
</dd></dl>

<dl class="type">
<dt id="rados_omap_iter_t">
<span class="target" id="Cephlibrados_8h_1aa90e492075bc31d7037695d79a4bf136"></span><em class="property">typedef </em><tt class="descname">rados_omap_iter_t</tt><a class="headerlink" href="#rados_omap_iter_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator for listing omap key/value pairs on an object. Used with rados_read_op_omap_get_keys(), rados_read_op_omap_get_vals(), rados_read_op_omap_get_vals_by_keys(), rados_omap_get_next(), and rados_omap_get_end(). </p>
</dd></dl>

<dl class="type">
<dt id="rados_write_op_t">
<span class="target" id="Cephlibrados_8h_1a8d8e4bd6677c21be8527089d735d8c9f"></span><em class="property">typedef </em><tt class="descname">rados_write_op_t</tt><a class="headerlink" href="#rados_write_op_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An object write operation stores a number of operations which can be executed atomically. For usage, see:<ul class="simple">
<li>Creation and deletion: rados_create_write_op() rados_release_write_op()</li>
<li>Extended attribute manipulation: rados_write_op_cmpxattr() rados_write_op_cmpxattr(), rados_write_op_setxattr(), rados_write_op_rmxattr()</li>
<li>Object map key/value pairs: rados_write_op_omap_set(), rados_write_op_omap_rm_keys(), rados_write_op_omap_clear(), rados_write_op_omap_cmp()</li>
<li>Object properties: rados_write_op_assert_exists(), rados_write_op_assert_version()</li>
<li>Creating objects: rados_write_op_create()</li>
<li>IO on objects: rados_write_op_append(), rados_write_op_write(), rados_write_op_zero rados_write_op_write_full(), rados_write_op_remove, rados_write_op_truncate(), rados_write_op_zero()</li>
<li>Hints: rados_write_op_set_alloc_hint()</li>
<li>Performing the operation: rados_write_op_operate(), rados_aio_write_op_operate() </li>
</ul>
</p>
</dd></dl>

<dl class="type">
<dt id="rados_read_op_t">
<span class="target" id="Cephlibrados_8h_1a6b0c4c8af0568903adcdd3b376c9d0c3"></span><em class="property">typedef </em><tt class="descname">rados_read_op_t</tt><a class="headerlink" href="#rados_read_op_t" title="Permalink to this definition">¶</a></dt>
<dd><p>An object read operation stores a number of operations which can be executed atomically. For usage, see:<ul class="simple">
<li>Creation and deletion: rados_create_read_op() rados_release_read_op()</li>
<li>Extended attribute manipulation: rados_read_op_cmpxattr(), rados_read_op_getxattr(), rados_read_op_getxattrs()</li>
<li>Object map key/value pairs: rados_read_op_omap_get_vals(), rados_read_op_omap_get_keys(), rados_read_op_omap_get_vals_by_keys(), rados_read_op_omap_cmp()</li>
<li>Object properties: rados_read_op_stat(), rados_read_op_assert_exists(), rados_read_op_assert_version()</li>
<li>IO on objects: rados_read_op_read()</li>
<li>Custom operations: rados_read_op_exec(), rados_read_op_exec_user_buf()</li>
<li>Request properties: rados_read_op_set_flags()</li>
<li>Performing the operation: rados_read_op_operate(), rados_aio_read_op_operate() </li>
</ul>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="__anonymous0">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55b"></span><em class="property">enum </em><tt class="descname"><strong>[anonymous]</strong></tt><a class="headerlink" href="#__anonymous0" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Values:</em></p>
<dl class="member">
<dt id="LIBRADOS_OP_FLAG_EXCL">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55baff6ea20a1a925a1498302cad07b4ff52"></span><tt class="descname">LIBRADOS_OP_FLAG_EXCL</tt> =  0x1<a class="headerlink" href="#LIBRADOS_OP_FLAG_EXCL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FAILOK">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55ba2c73bded10de4b1a8754a89e7ae93887"></span><tt class="descname">LIBRADOS_OP_FLAG_FAILOK</tt> = 0x2<a class="headerlink" href="#LIBRADOS_OP_FLAG_FAILOK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FADVISE_RANDOM">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55bab5be2a94eb79badadc9456c45d6f1841"></span><tt class="descname">LIBRADOS_OP_FLAG_FADVISE_RANDOM</tt> = 0x4<a class="headerlink" href="#LIBRADOS_OP_FLAG_FADVISE_RANDOM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55ba0c8c16bf2b135b5bf519389ed4b79742"></span><tt class="descname">LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL</tt> = 0x8<a class="headerlink" href="#LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FADVISE_WILLNEED">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55ba1b93fe7705f5b03384def1ad43b73a86"></span><tt class="descname">LIBRADOS_OP_FLAG_FADVISE_WILLNEED</tt> = 0x10<a class="headerlink" href="#LIBRADOS_OP_FLAG_FADVISE_WILLNEED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FADVISE_DONTNEED">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55ba75277c9bba643f4dfcd629549c7aeff7"></span><tt class="descname">LIBRADOS_OP_FLAG_FADVISE_DONTNEED</tt> = 0x20<a class="headerlink" href="#LIBRADOS_OP_FLAG_FADVISE_DONTNEED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="LIBRADOS_OP_FLAG_FADVISE_NOCACHE">
<span class="target" id="Cephlibrados_8h_1a06fc87d81c62e9abb8790b6e5713c55ba6701f8ce0bcc4db4e36f1f744bc2751b"></span><tt class="descname">LIBRADOS_OP_FLAG_FADVISE_NOCACHE</tt> = 0x40<a class="headerlink" href="#LIBRADOS_OP_FLAG_FADVISE_NOCACHE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a7be6f8d87e887d3d1da13bf77f43b587"></span><tt class="descname">CEPH_RADOS_API void rados_version(int * major, int * minor, int * extra)</tt></dt>
<dd><p>Get the version of librados.</p>
<p>The version number is major.minor.extra. Note that this is unrelated to the Ceph version number.</p>
<p>TODO: define version semantics, i.e.:<ul class="simple">
<li>incrementing major is for backwards-incompatible changes</li>
<li>incrementing minor is for backwards-compatible changes</li>
<li>incrementing extra is for bug fixes</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">major</span></tt> - <p>where to store the major version number </p>
</li>
<li><tt class="first docutils literal"><span class="pre">minor</span></tt> - <p>where to store the minor version number </p>
</li>
<li><tt class="first docutils literal"><span class="pre">extra</span></tt> - <p>where to store the extra version number </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a865143515247a530c221cead44a3c482"></span><tt class="descname">CEPH_RADOS_API int rados_cluster_stat(rados_t cluster, struct  rados_cluster_stat_t  * result)</tt></dt>
<dd><p>Read usage info about the cluster</p>
<p>This tells you total space, space used, space available, and number of objects. These are not updated immediately when data is written, they are eventually consistent.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster to query </p>
</li>
<li><tt class="first docutils literal"><span class="pre">result</span></tt> - <p>where to store the results </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad962962c237c99a9188befff6c7f2ede"></span><tt class="descname">CEPH_RADOS_API int rados_cluster_fsid(rados_t cluster, char * buf, size_t len)</tt></dt>
<dd><p>Get the fsid of the cluster as a hexadecimal string.</p>
<p>The fsid is a unique id of an entire Ceph cluster.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE if the buffer is too short to contain the fsid </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>where to get the fsid </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to write the fsid </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>the size of buf in bytes (should be 37) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a764137a5aa25c7a725b14ac2b5a561a5"></span><tt class="descname">CEPH_RADOS_API int rados_wait_for_latest_osdmap(rados_t cluster)</tt></dt>
<dd><p>Get/wait for the most recent osdmap</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on sucess, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>the cluster to shutdown </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a662629ba980ffffa8a65b17481b435d6"></span><tt class="descname">CEPH_RADOS_API int rados_omap_get_next(rados_omap_iter_t iter, char ** key, char ** val, size_t * len)</tt></dt>
<dd><p>Get the next omap key/value pair on the object</p>
<p><dl class="docutils">
<dt><strong>Pre</strong></dt>
<dd>iter is a valid iterator</dd>
<dt><strong>Post</strong></dt>
<dd>key and val are the next key/value pair. key is null-terminated, and val has length len. If the end of the list has been reached, key and val are NULL, and len is 0. key and val will not be accessible after rados_omap_get_end() is called on iter, so if they are needed after that they should be copied.</dd>
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>iterator to advance </p>
</li>
<li><tt class="first docutils literal"><span class="pre">key</span></tt> - <p>where to store the key of the next omap entry </p>
</li>
<li><tt class="first docutils literal"><span class="pre">val</span></tt> - <p>where to store the value of the next omap entry </p>
</li>
<li><tt class="first docutils literal"><span class="pre">len</span></tt> - <p>where to store the number of bytes in val </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1acb0a5de9aed41fafb7cd6ded011f97a6"></span><tt class="descname">CEPH_RADOS_API void rados_omap_get_end(rados_omap_iter_t iter)</tt></dt>
<dd><p>Close the omap iterator.</p>
<p>iter should not be used after this is called.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">iter</span></tt> - <p>the iterator to close </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ad7a13f3f1c0b5e0fe2c46d4213ecb4ae"></span><tt class="descname">CEPH_RADOS_API int rados_stat(rados_ioctx_t io, const char * o, uint64_t * psize, time_t * pmtime)</tt></dt>
<dd><p>Get object stats (size/mtime)</p>
<p>TODO: when are these set, and by whom? can they be out of date?</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>object name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">psize</span></tt> - <p>where to store object size </p>
</li>
<li><tt class="first docutils literal"><span class="pre">pmtime</span></tt> - <p>where to store modification time </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2899b207714ad34c2a3339bf2f2d55ca"></span><tt class="descname">CEPH_RADOS_API int rados_tmap_update(rados_ioctx_t io, const char * o, const char * cmdbuf, size_t cmdbuflen)</tt></dt>
<dd><p>Update tmap (trivial map)</p>
<p>Do compound update to a tmap object, inserting or deleting some number of records. cmdbuf is a series of operation byte codes, following by command payload. Each command is a single-byte command code, whose value is one of CEPH_OSD_TMAP_*.</p>
<p><ul class="simple">
<li>update tmap &#8216;header&#8217;<ul>
<li>1 byte = CEPH_OSD_TMAP_HDR</li>
<li>4 bytes = data length (little endian)</li>
<li>N bytes = data</li>
</ul>
</li>
<li>insert/update one key/value pair<ul>
<li>1 byte = CEPH_OSD_TMAP_SET</li>
<li>4 bytes = key name length (little endian)</li>
<li>N bytes = key name</li>
<li>4 bytes = data length (little endian)</li>
<li>M bytes = data</li>
</ul>
</li>
<li>insert one key/value pair; return -EEXIST if it already exists.<ul>
<li>1 byte = CEPH_OSD_TMAP_CREATE</li>
<li>4 bytes = key name length (little endian)</li>
<li>N bytes = key name</li>
<li>4 bytes = data length (little endian)</li>
<li>M bytes = data</li>
</ul>
</li>
<li>remove one key/value pair<ul>
<li>1 byte = CEPH_OSD_TMAP_RM</li>
<li>4 bytes = key name length (little endian)</li>
<li>N bytes = key name</li>
</ul>
</li>
</ul>
</p>
<p>Restrictions:<ul class="simple">
<li>The HDR update must preceed any key/value updates.</li>
<li>All key/value updates must be in lexicographically sorted order in cmdbuf.</li>
<li>You can read/write to a tmap object via the regular APIs, but you should be careful not to corrupt it. Also be aware that the object format may change without notice.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>object name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmdbuf</span></tt> - <p>command buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cmdbuflen</span></tt> - <p>command buffer length in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a862cac022c8a12a904f730fa05167e56"></span><tt class="descname">CEPH_RADOS_API int rados_tmap_put(rados_ioctx_t io, const char * o, const char * buf, size_t buflen)</tt></dt>
<dd><p>Store complete tmap (trivial map) object</p>
<p>Put a full tmap object into the store, replacing what was there.</p>
<p>The format of buf is:<ul class="simple">
<li>4 bytes - length of header (little endian)</li>
<li>N bytes - header data</li>
<li>4 bytes - number of keys (little endian)</li>
</ul>
</p>
<p>and for each key,<ul class="simple">
<li>4 bytes - key name length (little endian)</li>
<li>N bytes - key name</li>
<li>4 bytes - value length (little endian)</li>
<li>M bytes - value data</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>object name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buflen</span></tt> - <p>buffer length in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab34aaa6c90333775be0c871f5c3f021d"></span><tt class="descname">CEPH_RADOS_API int rados_tmap_get(rados_ioctx_t io, const char * o, char * buf, size_t buflen)</tt></dt>
<dd><p>Fetch complete tmap (trivial map) object</p>
<p>Read a full tmap object. See rados_tmap_put() for the format the data is returned in.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE if buf isn&#8217;t big enough </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>ioctx </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>object name </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buflen</span></tt> - <p>buffer length in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a53adcdedd6b93cd9bde6c0e97a6b4d79"></span><tt class="descname">CEPH_RADOS_API int rados_exec(rados_ioctx_t io, const char * oid, const char * cls, const char * method, const char * in_buf, size_t in_len, char * buf, size_t out_len)</tt></dt>
<dd><p>Execute an OSD class method on an object</p>
<p>The OSD has a plugin mechanism for performing complicated operations on an object atomically. These plugins are called classes. This function allows librados users to call the custom methods. The input and output formats are defined by the class. Classes in ceph.git can be found in src/cls subdirectories</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the length of the output, or -ERANGE if out_buf does not have enough space to store it (For methods that return data). For methods that don&#8217;t return data, the return value is method-specific. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context in which to call the method </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the object to call the method on </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cls</span></tt> - <p>the name of the class </p>
</li>
<li><tt class="first docutils literal"><span class="pre">method</span></tt> - <p>the name of the method </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_buf</span></tt> - <p>where to find input </p>
</li>
<li><tt class="first docutils literal"><span class="pre">in_len</span></tt> - <p>length of in_buf in bytes </p>
</li>
<li><tt class="first docutils literal"><span class="pre">buf</span></tt> - <p>where to store output </p>
</li>
<li><tt class="first docutils literal"><span class="pre">out_len</span></tt> - <p>length of buf in bytes </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab16f58c1b95d4d8e9e91f82de5f4f1a9"></span><tt class="descname">CEPH_RADOS_API int rados_lock_exclusive(rados_ioctx_t io, const char * oid, const char * name, const char * cookie, const char * desc, struct timeval * duration, uint8_t flags)</tt></dt>
<dd><p>Take an exclusive lock on an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-EBUSY if the lock is already held by another (client, cookie) pair </dd>
<dt><strong>Return</strong></dt>
<dd>-EEXIST if the lock is already held by the same (client, cookie) pair </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">oid</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the name of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>user-defined identifier for this instance of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">desc</span></tt> - <p>user-defined lock description </p>
</li>
<li><tt class="first docutils literal"><span class="pre">duration</span></tt> - <p>the duration of the lock. Set to NULL for infinite duration. </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>lock flags </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a2c6b48376f9bb95c8d2f9e332b4aeaf5"></span><tt class="descname">CEPH_RADOS_API int rados_lock_shared(rados_ioctx_t io, const char * o, const char * name, const char * cookie, const char * tag, const char * desc, struct timeval * duration, uint8_t flags)</tt></dt>
<dd><p>Take a shared lock on an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-EBUSY if the lock is already held by another (client, cookie) pair </dd>
<dt><strong>Return</strong></dt>
<dd>-EEXIST if the lock is already held by the same (client, cookie) pair </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the name of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>user-defined identifier for this instance of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">tag</span></tt> - <p>The tag of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">desc</span></tt> - <p>user-defined lock description </p>
</li>
<li><tt class="first docutils literal"><span class="pre">duration</span></tt> - <p>the duration of the lock. Set to NULL for infinite duration. </p>
</li>
<li><tt class="first docutils literal"><span class="pre">flags</span></tt> - <p>lock flags </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a9190641a8d05ba18002fe4e1f08ebae1"></span><tt class="descname">CEPH_RADOS_API int rados_unlock(rados_ioctx_t io, const char * o, const char * name, const char * cookie)</tt></dt>
<dd><p>Release a shared or exclusive lock on an object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ENOENT if the lock is not held by the specified (client, cookie) pair </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the name of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>user-defined identifier for the instance of the lock </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a5bbe10652a96add66edf90c8d737f6e9"></span><tt class="descname">CEPH_RADOS_API ssize_t rados_list_lockers(rados_ioctx_t io, const char * o, const char * name, int * exclusive, char * tag, size_t * tag_len, char * clients, size_t * clients_len, char * cookies, size_t * cookies_len, char * addrs, size_t * addrs_len)</tt></dt>
<dd><p>List clients that have locked the named object lock and information about the lock.</p>
<p>The number of bytes required in each buffer is put in the corresponding size out parameter. If any of the provided buffers are too short, -ERANGE is returned after these sizes are filled in.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>number of lockers on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ERANGE if any of the buffers are too short </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the name of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">exclusive</span></tt> - <p>where to store whether the lock is exclusive (1) or shared (0) </p>
</li>
<li><tt class="first docutils literal"><span class="pre">tag</span></tt> - <p>where to store the tag associated with the object lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">tag_len</span></tt> - <p>number of bytes in tag buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">clients</span></tt> - <p>buffer in which locker clients are stored, separated by &#8216;\0&#8217; </p>
</li>
<li><tt class="first docutils literal"><span class="pre">clients_len</span></tt> - <p>number of bytes in the clients buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookies</span></tt> - <p>buffer in which locker cookies are stored, separated by &#8216;\0&#8217; </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookies_len</span></tt> - <p>number of bytes in the cookies buffer </p>
</li>
<li><tt class="first docutils literal"><span class="pre">addrs</span></tt> - <p>buffer in which locker addresses are stored, separated by &#8216;\0&#8217; </p>
</li>
<li><tt class="first docutils literal"><span class="pre">addrs_len</span></tt> - <p>number of bytes in the clients buffer </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1a541c71bbd6497cb92c4933bab8f12afd"></span><tt class="descname">CEPH_RADOS_API int rados_break_lock(rados_ioctx_t io, const char * o, const char * name, const char * client, const char * cookie)</tt></dt>
<dd><p>Releases a shared or exclusive lock on an object, which was taken by the specified client.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Return</strong></dt>
<dd>-ENOENT if the lock is not held by the specified (client, cookie) pair </dd>
<dt><strong>Return</strong></dt>
<dd>-EINVAL if the client cannot be parsed </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">io</span></tt> - <p>the context to operate in </p>
</li>
<li><tt class="first docutils literal"><span class="pre">o</span></tt> - <p>the name of the object </p>
</li>
<li><tt class="first docutils literal"><span class="pre">name</span></tt> - <p>the name of the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">client</span></tt> - <p>the client currently holding the lock </p>
</li>
<li><tt class="first docutils literal"><span class="pre">cookie</span></tt> - <p>user-defined identifier for the instance of the lock </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="Cephlibrados_8h_1ab21db9859670ba925ae1bbc7e150e968"></span><tt class="descname">CEPH_RADOS_API int rados_blacklist_add(rados_t cluster, char * client_address, uint32_t expire_seconds)</tt></dt>
<dd><p>Blacklists the specified client from the OSDs</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 on success, negative error code on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><tt class="first docutils literal"><span class="pre">cluster</span></tt> - <p>cluster handle </p>
</li>
<li><tt class="first docutils literal"><span class="pre">client_address</span></tt> - <p>client address </p>
</li>
<li><tt class="first docutils literal"><span class="pre">expire_seconds</span></tt> - <p>number of seconds to blacklist (0 for default) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<dl class="class">
<dt id="rados_pool_stat_t">
<span class="target" id="Cephstructrados__pool__stat__t"></span><em class="property">struct </em><tt class="descname">rados_pool_stat_t</tt><a class="headerlink" href="#rados_pool_stat_t" title="Permalink to this definition">¶</a></dt>
<dd><em>#include &lt;librados.h&gt;</em><p>Usage information for a pool. </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="rados_pool_stat_t::num_bytes__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1ae6385fec35785692a72ded4521051349"></span>uint64_t <tt class="descname">num_bytes</tt><a class="headerlink" href="#rados_pool_stat_t::num_bytes__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>space used in bytes </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_kb__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1ab9dfedb097f054908307faaa66b7e109"></span>uint64_t <tt class="descname">num_kb</tt><a class="headerlink" href="#rados_pool_stat_t::num_kb__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>space used in KB </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_objects__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1ad0f3fc2289e2242e4d81475b3b9c6ee7"></span>uint64_t <tt class="descname">num_objects</tt><a class="headerlink" href="#rados_pool_stat_t::num_objects__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>number of objects in the pool </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_object_clones__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1a934a353ee4ee657b1e47b66ffc99ee02"></span>uint64_t <tt class="descname">num_object_clones</tt><a class="headerlink" href="#rados_pool_stat_t::num_object_clones__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>number of clones of objects </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_object_copies__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1a3e537978ffb81be0a6355f3bb6159290"></span>uint64_t <tt class="descname">num_object_copies</tt><a class="headerlink" href="#rados_pool_stat_t::num_object_copies__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>num_objects * num_replicas </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_objects_missing_on_primary__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1a2f0995af81b64c8678dc4bdecd42a8c5"></span>uint64_t <tt class="descname">num_objects_missing_on_primary</tt><a class="headerlink" href="#rados_pool_stat_t::num_objects_missing_on_primary__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_objects_unfound__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1a1be8f89a42f68ef7f25d5dcf728ea7b0"></span>uint64_t <tt class="descname">num_objects_unfound</tt><a class="headerlink" href="#rados_pool_stat_t::num_objects_unfound__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>number of objects found on no OSDs </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_objects_degraded__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1af63ab0187a498098d898f4dd1b49cb5c"></span>uint64_t <tt class="descname">num_objects_degraded</tt><a class="headerlink" href="#rados_pool_stat_t::num_objects_degraded__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd><p>number of objects replicated fewer times than they should be (but found on at least one OSD) </p>
</dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_rd__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1aca0e0d878b451946c96a8f0fb46075df"></span>uint64_t <tt class="descname">num_rd</tt><a class="headerlink" href="#rados_pool_stat_t::num_rd__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_rd_kb__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1abef90de3656e1aa464e70661bff8220b"></span>uint64_t <tt class="descname">num_rd_kb</tt><a class="headerlink" href="#rados_pool_stat_t::num_rd_kb__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_wr__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1a8c77f7bf4c192e522df7496288f23f8f"></span>uint64_t <tt class="descname">num_wr</tt><a class="headerlink" href="#rados_pool_stat_t::num_wr__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_pool_stat_t::num_wr_kb__uint64_t">
<span class="target" id="Cephstructrados__pool__stat__t_1af56c7186ba19df57f7978b6ce734361a"></span>uint64_t <tt class="descname">num_wr_kb</tt><a class="headerlink" href="#rados_pool_stat_t::num_wr_kb__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="rados_cluster_stat_t">
<span class="target" id="Cephstructrados__cluster__stat__t"></span><em class="property">struct </em><tt class="descname">rados_cluster_stat_t</tt><a class="headerlink" href="#rados_cluster_stat_t" title="Permalink to this definition">¶</a></dt>
<dd><em>#include &lt;librados.h&gt;</em><p>Cluster-wide usage information </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="rados_cluster_stat_t::kb__uint64_t">
<span class="target" id="Cephstructrados__cluster__stat__t_1a37633ef0eb7d786d06869a7401167966"></span>uint64_t <tt class="descname">kb</tt><a class="headerlink" href="#rados_cluster_stat_t::kb__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_cluster_stat_t::kb_used__uint64_t">
<span class="target" id="Cephstructrados__cluster__stat__t_1ac2c7d8f0977feed733742e5a1d046f5e"></span>uint64_t <tt class="descname">kb_used</tt><a class="headerlink" href="#rados_cluster_stat_t::kb_used__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_cluster_stat_t::kb_avail__uint64_t">
<span class="target" id="Cephstructrados__cluster__stat__t_1aeb381150d5a01aeb57015512d820b302"></span>uint64_t <tt class="descname">kb_avail</tt><a class="headerlink" href="#rados_cluster_stat_t::kb_avail__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="rados_cluster_stat_t::num_objects__uint64_t">
<span class="target" id="Cephstructrados__cluster__stat__t_1addd82ed2ef92adc7ecb8c051ad68bd66"></span>uint64_t <tt class="descname">num_objects</tt><a class="headerlink" href="#rados_cluster_stat_t::num_objects__uint64_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../">
              <img class="logo" src="../../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../../">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../start/intro/">Ceph 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../start/">安装（快速）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/">安装（手动）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rados/">Ceph 存储集群</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cephfs/">Ceph 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rbd/rbd/">Ceph 块设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../radosgw/">Ceph 对象网关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../architecture/">体系结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/">开发文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release-notes/">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../releases/">发布时间表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary/">Ceph 术语</a></li>
</ul>


<!-- ugly kludge to make genindex look like it's part of the toc -->
<ul style="margin-top: -10px"><li class="toctree-l1"><a class="reference internal" href="../../../../genindex/">Index</a></li></ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../">Ceph Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2014, Inktank Storage, Inc. and contributors. Licensed under Creative Commons BY-SA.
    </div>
  </body>
</html>